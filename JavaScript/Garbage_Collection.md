# 📆 날짜: 2023-09-22

## 🎯 공통 질문: Javascript에서 garbage collection은 무엇입니까?

### 나라's 답변:

JavaScript가 메모리 관리를 위해 사용되지 않는 메모리를 자동으로 탐지하고 해제하는 프로세스를 garbage collection라고 합니다.

---

## <!-- 답변 -->

### 슬기's 답변:

---

## <!-- 답변 -->

## 🔗 나라's 꼬리질문: 새로운 객체가 아니라면 메모리에 할당이 안될까요?

### 나라's 답변:

새로운 객체 아니더라도 대부분의 값을 새롭게 정의한다면 메모리에 할당이 됩니다.

### 슬기's 답변:

## 🔗 나라's 꼬리질문: 가비지컬렉터는 어떨때 작동될까요?

### 나라's 답변:

가비지컬렉터는 동적으로 메모리를 관리하기에 명확한 시점이 정의되지 않습니다. 하지만 브라우저의 차이, 메모리 사용량의 차이, 내부 메모리 관리 최적화에 차이에 따라 달라질 수 있습니다.

### 슬기's 답변:

## 🔗 나라's 꼬리질문: 참조가 끊겼때만 작동될까요?

### 나라's 답변:

이전 질문과 같이 특정 객체에서 참조가 끊겼다고 해서 가비지 컬렉터가 작동되는 것은 아닙니다. 참조가 끊어졌을 경우 해당 객체는 가비지로 간주되며 다음 가비지 컬렉터가 작동되었을 때 수집되어집니다.

### 슬기's 답변:

## 🔗 나라's 꼬리질문: 엔진이 판단하는 기준?

### 나라's 답변:

참조가 끊겼거나 mark and sweep 알고리즘에서는 도달하지 못하는 객체를 "가비지"로 판단합니다.

### 슬기's 답변:

## 🔗 나라's 꼬리질문: 순환참조를 하고 있다면 가비지 컬렉션을 하지 않을까요?

### 나라's 답변:

현대 자바스크립트에서는 mark-and-sweep알고리즘이 사용되어서 객체가 root에서 도달할 수 없다면 순환참조가 되고있다고하더라도 가비지컬렉션의 대상이 됩니다.

### 슬기's 답변:

## 🔗 나라's 꼬리질문: 가비지 컬렉션에서 사용할 수 있는 최적화을 할 수 있는 것을 알고계신게 있을까요?

### 나라's 답변:

세대별 수집을 말씀드릴 수 있습니다. 세대별 수집이란 객체가 새롭게 생성된 이후 역할을 빠르게 수행하고 사용되지 않습니다. 이런 로직을 활용하여 바로 생성된 객체를 공격적으로 메모리에서 제거하며 오래동안 살아남은 객체는 비교적 가비지 컬렉터가 감시 비중을 줄이는 최적화입니다.
메모리 누수를 방지하는 방법은 전역변수를 줄이면서 개발, 타이머 api를 사용했다면 꼭 clear를 사용하는 것, 이벤트 리스너 제거, 클로저 사용시 반드시 참조를 null로 변경 등이 있습니다.

### 슬기's 답변:

## 🔗 나라's 꼬리질문: 마크앤 스윕에 대해서 단계별로 설명 가능할까요?

### 나라's 답변:

root에서 시작되어 참조가 되어진 객체를 방문하여 기억(mark)합니다. 이후 방문한 객체에서도 참조되어진 객체를 방문하여 기억합니다. 이후 mark가 되지 않는 객체가 존재한다면 삭제(sweep)합니다.

### 슬기's 답변:

## 🔗 슬기's 꼬리질문: 메모리 관리란?

### 나라's 답변:

메모리관리란 메모리 리소스를 할당, 추적, 해제하는 프로세스의 집합이라고 생각합니다.
그중 JavaScript에서의 가비지 컬렉션은 프로그램에서 사용되지 않는 메모리를 해제하여 메모리를 효율적으로 사용할 수 있도록 하는 것입니다.

### 슬기's 답변:

## 🔗 슬기's 꼬리질문: 내부알고리즘 어떤알고리즘 사용하죠?

### 나라's 답변:

참조 카운트와 mark and sweep알고리즘을 사용합니다.
객체가 생성될 때 참조카운트가 0으로 지정되며 해당 객체에서 다른 곳에 참조를 할 경우 카운트가 1이 증가, 참조가 끊겼을 때 감소합니다. 이때 참조 카운트가 0일때 "가비지" 로 판단하며 다음 가비지컬렉션이 작동될 때 가비지 컬렉션이 이뤄집니다.
mark and sweep은 도달 가능성을 비교하여 root에서 도달할 수 있는냐 없느냐로 "가비지"로 취급합니다.

### 슬기's 답변:

## 🔗 슬기's 꼬리질문: 참조카운팅의 단점은?

### 나라's 답변:

만약 함수 실행이 끝나더라도 객체의 참조가 끊이지 않았을 때 즉, 순환참조가 일어나고있다면 가비지 컬렉터가 해당 객체를 메모리에서 삭제하지 않는 단점이 존재합니다.

### 슬기's 답변:

## 🔗 슬기's 꼬리질문: 마크앤스윕은 순환참조 문제가 일어나지않나요?

### 나라's 답변:

mark and sweep알고리즘은 root에서 참조가 끊길 경우 해당 객체를 가비지로 인식하기 때문에 순환참조 문제를 해결할 수 있습니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: 가비지 컬렉션과 메모리 누수의 차이점은 무엇인가요?

### 나라's 답변:

가비지 컬렉션은 시스템에서 자동으로 수행되는 프로세스이며 참조되지 않는 객체를 메모리에서 삭제하는 것입니다. 메모리 누수 또한 사용하지 않는 메모리가 삭제되어지지 않아 메모리 사용량이 증가하는 현상을 말하는 것입니다.
즉, 가비지 컬렉션은 사용되는 프로세스이며 메모리 누수는 발생하는 현상이라는 것이 차이점이라고 말할 수 있습니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: 가비지 컬렉션의 주기나 타이밍을 개발자가 직접 조절할 수 있나요?

### 나라's 답변:

가비지 컬렉션의 주기나 타이밍을 개발자가 직접 조작할 수는 없습니다. 하지만 이전에 말했던 markandsweep이나 세대별 수집같은 최적화를 통해 가비지 컬렉터를 좀 더 효율성 높게 개발 할 수 있습니다.
또한 메모리 사용량이 특정 값을 초과하거나, 일정 시간 간격일 때 등에 가비지 컬렉션 작업이 트리거 되는 시점이라고 말씀드릴 수 있습니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: WeakMap과 WeakSet은 가비지 컬렉션에 어떤 영향을 주나요?

### 나라's 답변:

WeakMap과 WeakSet을 사용했을 때 참조를 이루는 것은 약한참조를 하기 때문에 일반적인 Map, Set을 사용할 때 보다 가비지 컬렉션의 대상이 될 가능성이 높기 때문에 메모리 누수적인 측면에서 위험성이 떨어질 수 있습니다.
고로 메모리 관리에서 더 효율적인 부분이 존재합니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: 브라우저마다 가비지 컬렉션의 작동 방식에 차이가 있을까요?

### 나라's 답변:

각 브라우저에서 사용되는 엔진마다 JavaScript를 다루는 방식의 차이가 있기때문에 작동 방식의 차이가 존재합니다.
예를들어 V8엔진을 사용하는 브라우저는 MarkandSweep알고리즘은 사용하여 도달 불가능한 객체를 식별할 수 있고, SpiderMonkey엔진을 사용하는 브라우저는 Incremental Garbage Collection을 구현하여 메모리를 여러단계로 나누어 수집하는 방식을 채용하여 G.C의 가비지 컬렉션의 일시 중단을 최소화시킵니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: 실제 코드에서 메모리 누수를 발견하고 해결했던 경험이 있다면 그 과정을 설명해주세요.

### 나라's 답변:

화면에서 버튼을 1초뒤에 생성하고 사라지게끔 코드를 작성하기 위해 setTimeout을 사용하고 clear함수를 작성하지 않아서 StackoverFlow에러를 만난 경험이 있습니다. 해당 경험을 할 때는 간단한 코드라서 디버깅에 어려움이 있지않았지만 처음 만났던 메모리 누수라서 기억에 남아있습니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: 가비지 컬렉션을 과도하게 동작시키지 않기 위한 코드 최적화 방법은 무엇인가요?

### 나라's 답변:

세대별 수집(generational collection)을 통해서 오래살아남은 객체는 가비지 컬렉터가 수집 비중을 줄이는 방식이 있으며 점진적 수집 (incremental collection)을 통해 가비지 컬렉션을 부분적으로 분리 후 별도로 수행하는 방식도 존재합니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: 가비지 컬렉션의 작동 원리를 이해하는 것이 프론트엔드 개발자에게 어떤 이점을 가져다주나요?

### 나라's 답변:

웹개발이 발전하면서 유저들이 웹상에 머무르는 시간이 높아지고 그에따라 기대하는 성능치도 높아졌다고 생각합니다. 프론트엔드 개발자는 유저의 눈높이에 맞춰서 개발해야하기에 성능 최적화가 필수라고 생각합니다.
가비지컬렉션 원리를 알고 최적화하는 것은 빠른 서비스를 보여주는 것에 큰 도움이 될 것이며 이는 유저의 경험에 직결된다고 생각합니다.

### 슬기's 답변:

## 🔗 GPT's 꼬리질문: 자바스크립트 외의 다른 언어에서의 가비지 컬렉션 방식과 비교했을 때 자바스크립트의 특징은 무엇인가요?

### 나라's 답변:

JavaScript의 가비지 컬렉션 방식은 웹 브라우저 환경에서 동작하기 페이지가 닫히게 된다면 관련 메모리도 해제가 되는 특징이 존재합니다. 그에비해 타 언어들은 일반적으로 애플리케이션을 위한 설계가 되어있으므로 가비지 컬렉션도 애플리케이션에 맞추어서 설계되어 있습니다.

### 슬기's 답변:

---

#### REFERENCE

##### 나라

[javascript 메모리 누수](https://yceffort.kr/2020/07/memory-leaks-in-javascript)
[javascript 가비지 컬렉션](https://ko.javascript.info/garbage-collection)

##### 슬기

<!-- 답변 -->
