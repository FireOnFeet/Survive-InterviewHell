# 📆 날짜: 2023-09-22

## 🎯 공통 질문: Javascript에서 garbage collection은 무엇입니까?

### 나라's 답변:

JavaScript가 메모리 관리를 위해 사용되지 않는 메모리를 자동으로 탐지하고 해제하는 프로세스를 garbage collection라고 합니다.

---

## <!-- 답변 -->

### 슬기's 답변:

---

## 가비지 컬렉션은 자바스크립트에서 자동으로 메모리를 관리해주는 한 방식으로, 도달불가능한 객체를 감지하여 메모리를 해제하는 프로세스입니다.

## 🔗 나라's 꼬리질문: 새로운 객체가 아니라면 메모리에 할당이 안될까요?

### 나라's 답변:

새로운 객체 아니더라도 대부분의 값을 새롭게 정의한다면 메모리에 할당이 됩니다.

### 슬기's 답변:

새로운 객체 뿐만아니라 다른 데이터타입들 또한 메모리에 할당됩니다.

## 🔗 나라's 꼬리질문: 가비지컬렉터는 어떨때 작동될까요?

### 나라's 답변:

가비지컬렉터는 동적으로 메모리를 관리하기에 명확한 시점이 정의되지 않습니다. 하지만 브라우저의 차이, 메모리 사용량의 차이, 내부 메모리 관리 최적화에 차이에 따라 달라질 수 있습니다.

### 슬기's 답변:

메모리관리 중 도달가능성이라는 개념이 있습니다. 어떤 값이 접근 가능하거나 필요한 경우를 의미하는데 만약 참조가 끊긴 경우에는 도달가능성이 사라지고 이경우 가비지로 생각되어 가비지컬렉터가 동작하는것으로 알고있습니다.

## 🔗 나라's 꼬리질문: 참조가 끊겼때만 작동될까요?

### 나라's 답변:

이전 질문과 같이 특정 객체에서 참조가 끊겼다고 해서 가비지 컬렉터가 작동되는 것은 아닙니다. 참조가 끊어졌을 경우 해당 객체는 가비지로 간주되며 다음 가비지 컬렉터가 작동되었을 때 수집되어집니다.

### 슬기's 답변:

참조가 끊겼을 경우 뿐만아니라 변수에 null, undefined를 할당하는것은 변수의 참조를 끊는 행위로 그 변수가 참조하던 객체가 다른곳에서 참조되지않는다면 그 객체 역시 메모리에서 해제될 수 있습니다.

## 🔗 나라's 꼬리질문: 엔진이 판단하는 기준?

### 나라's 답변:

참조가 끊겼거나 mark and sweep 알고리즘에서는 도달하지 못하는 객체를 "가비지"로 판단합니다.

### 슬기's 답변:

엔진마다 가비지 컬렉션에 대한 판단 기준이 다르지만, V8 엔진의 경우에는 mark-sweep 알고리즘을 기본적으로 사용하여 도달 가능한 객체를 표시하고, 표시되지 않은 객체들을 메모리에서 제거합니다.

## 🔗 나라's 꼬리질문: 순환참조를 하고 있다면 가비지 컬렉션을 하지 않을까요?

### 나라's 답변:

현대 자바스크립트에서는 mark-and-sweep알고리즘이 사용되어서 객체가 root에서 도달할 수 없다면 순환참조가 되고있다고하더라도 가비지컬렉션의 대상이 됩니다.

### 슬기's 답변:

순환참조의 경우 알고리즘마다 판단하는 것이 다른데, 예전 참조카운팅알고리즘을 사용하였을 때에는 순환참조의 경우 가비지 컬렉션의 대상이 되지않는 문제가 있었지만, 요즘은 mark-sweep과 같은 도달가능성 기반으로 가바지컬렉션의 방식을 사용하기에 문제가 되지 않는것으로 알고있습니다.
두 객체가 서로를 참조하고 있더라도 외부에서 둘다 접근할 수 없다면 이 객체들은 가비지 컬렉터에의해 메모리에서 해제됩니다.

## 🔗 나라's 꼬리질문: 가비지 컬렉션에서 사용할 수 있는 최적화을 할 수 있는 것을 알고계신게 있을까요?

### 나라's 답변:

세대별 수집을 말씀드릴 수 있습니다. 세대별 수집이란 객체가 새롭게 생성된 이후 역할을 빠르게 수행하고 사용되지 않습니다. 이런 로직을 활용하여 바로 생성된 객체를 공격적으로 메모리에서 제거하며 오래동안 살아남은 객체는 비교적 가비지 컬렉터가 감시 비중을 줄이는 최적화입니다.
메모리 누수를 방지하는 방법은 전역변수를 줄이면서 개발, 타이머 api를 사용했다면 꼭 clear를 사용하는 것, 이벤트 리스너 제거, 클로저 사용시 반드시 참조를 null로 변경 등이 있습니다.

### 슬기's 답변:

참조가 끊길 경우 명시적으로 null을 할당하고, 전역변수 보다는 로컬변수를 사용하며, 순환참조를 최대한 피하는것, es6에서 도입된 WeakMap, WeakSet을 사용하면 최적화 할 수 있다고 알고있습니다.

## 🔗 나라's 꼬리질문: 마크앤 스윕에 대해서 단계별로 설명 가능할까요?

### 나라's 답변:

root에서 시작되어 참조가 되어진 객체를 방문하여 기억(mark)합니다. 이후 방문한 객체에서도 참조되어진 객체를 방문하여 기억합니다. 이후 mark가 되지 않는 객체가 존재한다면 삭제(sweep)합니다.

### 슬기's 답변:

마킹 과 스윕의 단계를 가지게됩니다.
먼저 루트라고하는 출발점에서 시작하여 참조되는 모든 객체를 재귀적으로 탐색하고 마킹하며, 도달가능한 모든 객체는 마크되며 순환참조되는 객체도 마크의 대상이됩니다.
이후 스윕의 단계에서 마크되지않은 객체들이 가비지컬렉션의 대상이되어 제거되는 단계를가지게됩니다.

## 🔗 슬기's 꼬리질문: 메모리 관리란?

### 나라's 답변:

메모리관리란 메모리 리소스를 할당, 추적, 해제하는 프로세스의 집합이라고 생각합니다.
그중 JavaScript에서의 가비지 컬렉션은 프로그램에서 사용되지 않는 메모리를 해제하여 메모리를 효율적으로 사용할 수 있도록 하는 것입니다.

### 슬기's 답변:

크게 세단계로 이루어집니다. 첫번째 필요한 메모리를 할당하고, 두번째 할당된 메모리를 사용하고 세번째 완료된 메모리를 해제하는 것입니다.

## 🔗 슬기's 꼬리질문: 내부알고리즘 어떤알고리즘 사용하죠?

### 나라's 답변:

참조 카운트와 mark and sweep알고리즘을 사용합니다.
객체가 생성될 때 참조카운트가 0으로 지정되며 해당 객체에서 다른 곳에 참조를 할 경우 카운트가 1이 증가, 참조가 끊겼을 때 감소합니다. 이때 참조 카운트가 0일때 "가비지" 로 판단하며 다음 가비지컬렉션이 작동될 때 가비지 컬렉션이 이뤄집니다.
mark and sweep은 도달 가능성을 비교하여 root에서 도달할 수 있는냐 없느냐로 "가비지"로 취급합니다.

### 슬기's 답변:

자바스크립트의 메모리 관리에 사용되는 내부 알고리즘은 엔진마다 다르지만, 주요한 가비지 컬렉션 알고리즘으로는 "참조 카운팅(reference counting)"과 "마크-앤-스윕(mark-and-sweep)"이 있습니다. <br/>
참조 카운팅은 객체에 대한 참조 횟수를 추적하여 참조 횟수가 0이 되면 메모리에서 해제하는 방식입니다. 반면, 마크-앤-스윕은 도달 가능한 객체를 "마킹"하고, 마킹되지 않은 객체를 "스윕"하여 메모리에서 제거하는 방식입니다.

## 🔗 슬기's 꼬리질문: 참조카운팅의 단점은?

### 나라's 답변:

만약 함수 실행이 끝나더라도 객체의 참조가 끊이지 않았을 때 즉, 순환참조가 일어나고있다면 가비지 컬렉터가 해당 객체를 메모리에서 삭제하지 않는 단점이 존재합니다.

### 슬기's 답변:

참조카운팅의 단점은 순환참조의 경우 가비지컬렉터의 대상이 되지않는다는것과, 각 객체에 대한 참조 카운트를 유지하고 업데이트해야하는 추가적인 메모리 및 연산이 필요하다는것입니다. 그렇기에 성능저하의 문제가 있습니다.

## 🔗 슬기's 꼬리질문: 마크앤스윕은 순환참조 문제가 일어나지않나요?

### 나라's 답변:


### 슬기's 답변:

네, 마크-스윕 에서 마크를 할때 순환참조 되는 객체 또한 마크의 대상이 되기에 순환참조여도 가비지컬렉터의 대상이 될 수 있습니다.


## 🔗 GPT's 꼬리질문: 가비지 컬렉션과 메모리 누수의 차이점은 무엇인가요?

### 나라's 답변:

가비지 컬렉션은 시스템에서 자동으로 수행되는 프로세스이며 참조되지 않는 객체를 메모리에서 삭제하는 것입니다. 메모리 누수 또한 사용하지 않는 메모리가 삭제되어지지 않아 메모리 사용량이 증가하는 현상을 말하는 것입니다.
즉, 가비지 컬렉션은 사용되는 프로세스이며 메모리 누수는 발생하는 현상이라는 것이 차이점이라고 말할 수 있습니다.

### 슬기's 답변:

가비지컬렉션은 메모리관리 기법 중 하나로, 더이상 사용하지 않는 메모리를 자동으로 해제하는 과정을 말하며,
메모리누수는 더이상 필요하지 않은 메모리를 계속해서 점유하고 있을 때 발생하는 현상을 의미합니다.

## 🔗 GPT's 꼬리질문: 가비지 컬렉션의 주기나 타이밍을 개발자가 직접 조절할 수 있나요?

### 나라's 답변:

가비지 컬렉션의 주기나 타이밍을 개발자가 직접 조작할 수는 없습니다. 하지만 이전에 말했던 markandsweep이나 세대별 수집같은 최적화를 통해 가비지 컬렉터를 좀 더 효율성 높게 개발 할 수 있습니다.
또한 메모리 사용량이 특정 값을 초과하거나, 일정 시간 간격일 때 등에 가비지 컬렉션 작업이 트리거 되는 시점이라고 말씀드릴 수 있습니다.

### 슬기's 답변:

주기나 타이밍을 완벽하게 조절할수는 없지만, 사용하지않는 것은 명확하게 제거해주는 것은 개발자가 할 수 있다 생각합니다.

## 🔗 GPT's 꼬리질문: WeakMap과 WeakSet은 가비지 컬렉션에 어떤 영향을 주나요?

### 나라's 답변:

WeakMap과 WeakSet을 사용했을 때 참조를 이루는 것은 약한참조를 하기 때문에 일반적인 Map, Set을 사용할 때 보다 가비지 컬렉션의 대상이 될 가능성이 높기 때문에 메모리 누수적인 측면에서 위험성이 떨어질 수 있습니다.
고로 메모리 관리에서 더 효율적인 부분이 존재합니다.

### 슬기's 답변:

WeakMap과 WeakSet은 가비지 컬렉션에 영향을 주지 않는 참조를 저장합니다. 즉, WeakMap이나 WeakSet에 객체를 저장해도, 이 객체들은 가비지 컬렉션의 대상이 될 수 있습니다. 따라서, 메모리 누수를 방지하는 데 도움을 줍니다.

## 🔗 GPT's 꼬리질문: 브라우저마다 가비지 컬렉션의 작동 방식에 차이가 있을까요?

### 나라's 답변:

각 브라우저에서 사용되는 엔진마다 JavaScript를 다루는 방식의 차이가 있기때문에 작동 방식의 차이가 존재합니다.
예를들어 V8엔진을 사용하는 브라우저는 MarkandSweep알고리즘은 사용하여 도달 불가능한 객체를 식별할 수 있고, SpiderMonkey엔진을 사용하는 브라우저는 Incremental Garbage Collection을 구현하여 메모리를 여러단계로 나누어 수집하는 방식을 채용하여 G.C의 가비지 컬렉션의 일시 중단을 최소화시킵니다.

### 슬기's 답변:

네, 브라우저마다 사용하는 엔진이 다르며 엔진마다 내부적으로 사용하는 가비지컬렉션의 알고리즘이 다르다고 알고있습니다.
주로 사용되는 v8엔진의 경우 마크앤스윕 알고리즘으로 가비지컬렉터가 동작하나, 다른 엔진의 경우 다른 최적화방법을 위한 다른 알고리즘들이 사용되는것으로 알고있습니다.

## 🔗 GPT's 꼬리질문: 실제 코드에서 메모리 누수를 발견하고 해결했던 경험이 있다면 그 과정을 설명해주세요.

### 나라's 답변:

화면에서 버튼을 1초뒤에 생성하고 사라지게끔 코드를 작성하기 위해 setTimeout을 사용하고 clear함수를 작성하지 않아서 StackoverFlow에러를 만난 경험이 있습니다. 해당 경험을 할 때는 간단한 코드라서 디버깅에 어려움이 있지않았지만 처음 만났던 메모리 누수라서 기억에 남아있습니다.

### 슬기's 답변:

리액트로 개발하며 timer함수를 이용해 개발을 시간마다 데이터를 업데이트 하는 함수를 생성하였을 때 clear함수를 같이 사용해주지않아 메모리 누수를 만든 적이있었습니다.
이 문제의 발견은 브라우저의 속도가 느려지며 개발자도구에서 메모리가 시간이 지남에 따라 사용량이 계속해서 증가함을 확인하였고, useEffect 내 타이머를 설정 후 clear 함수를 설정해 해결한 경험이있습니다.

## 🔗 GPT's 꼬리질문: 가비지 컬렉션을 과도하게 동작시키지 않기 위한 코드 최적화 방법은 무엇인가요?

### 나라's 답변:

세대별 수집(generational collection)을 통해서 오래살아남은 객체는 가비지 컬렉터가 수집 비중을 줄이는 방식이 있으며 점진적 수집 (incremental collection)을 통해 가비지 컬렉션을 부분적으로 분리 후 별도로 수행하는 방식도 존재합니다.

### 슬기's 답변:

변수의 범위를 최소화 하여 전역변수사용을 지양해야하며, 타이머 함수를 사용하였을 경우 clear함수를 사용해주는것, 순환 참조 피하는것, 재사용 가능한 데이터는 재사용하느것으로 최적화 할 수 있습니다.

## 🔗 GPT's 꼬리질문: 가비지 컬렉션의 작동 원리를 이해하는 것이 프론트엔드 개발자에게 어떤 이점을 가져다주나요?

### 나라's 답변:

웹개발이 발전하면서 유저들이 웹상에 머무르는 시간이 높아지고 그에따라 기대하는 성능치도 높아졌다고 생각합니다. 프론트엔드 개발자는 유저의 눈높이에 맞춰서 개발해야하기에 성능 최적화가 필수라고 생각합니다.
가비지컬렉션 원리를 알고 최적화하는 것은 빠른 서비스를 보여주는 것에 큰 도움이 될 것이며 이는 유저의 경험에 직결된다고 생각합니다.

### 슬기's 답변:

메모리 누수가 일어날 상황을 예상하여 메모리를 효율적으로 관리하며 메모리 누수를 방지하여 코드의 안정성을 높일 수 있습니다.

## 🔗 GPT's 꼬리질문: 자바스크립트 외의 다른 언어에서의 가비지 컬렉션 방식과 비교했을 때 자바스크립트의 특징은 무엇인가요?

### 나라's 답변:

JavaScript의 가비지 컬렉션 방식은 웹 브라우저 환경에서 동작하기 페이지가 닫히게 된다면 관련 메모리도 해제가 되는 특징이 존재합니다. 그에비해 타 언어들은 일반적으로 애플리케이션을 위한 설계가 되어있으므로 가비지 컬렉션도 애플리케이션에 맞추어서 설계되어 있습니다.

### 슬기's 답변:

자바스크립트는 주로 브라우저 환경에서 실행된다는 점과, 단일 스레드이기에 최적화가 중요하며 '도달가능성'을 기반으로 한다는 점이 가장 큰 특징입니다.

---

#### REFERENCE

##### 나라

[javascript 메모리 누수](https://yceffort.kr/2020/07/memory-leaks-in-javascript)
[javascript 가비지 컬렉션](https://ko.javascript.info/garbage-collection)

##### 슬기

- 가비지컬렉션이 뭐지?
  - 가비지컬렉션은 프로그램이 동적으로 할당한 메모리 중 더 이상 필요하지 않은 메모리를 자동으로 회수하는 프로세스를 의미함.
    - 메모리 누수 방지, 시스템의 안정성과 효율성 높이는 역할
    - 자바스크립트는 가비지 컬렉션을 내장하고 있는 언어
      - 주로 참조를 기반으로 가비지 컬렉션을 수행함
      - 객체에 대한 참조가 더이상 없으면 그 객체는 가비지로 간주
  - 자바스크립트에서는 객체를 자동으로 생성할 때 메모리를 할당하며, 해당 객체가 더 이상 사용되지 않을 때는 자동으로 메모리에서 제거하는 메모리 관리 기능을 가지고 있음
    - 메모리 라이프사이클 ?
      - 필요한 메모리를 할당한다.
      - 할당된 메모리를 사용한다
      - 할당된 메모리가 더이상 사용되지않을 때 제거한다.
- 왜 필요하지?
  - 메모리관리 자동화
    - 수동으로 메모리를 관리하면 휴먼 에러가 발생할 수 있음
  - 누수 방지
    - 왜 누수가 일어나지?
      - 계속 할당만 하고 해제하지 않으면 시스템 메모리가 고갈될 위험
      - 그렇게되면 메모리 사용량을 증가시켜 성능 저하나 시스템의 불안정성 초래할 수 있음
- 자바스크립트에서는 어떻게 누수를 방지하지?

  - 전역변수 사용최소화
    - 불필요한 전역변수는 메모리 누수의 원인이 될 수 있기에 필요없는 경우 null / undefined로 참조를 끊어야함
  - 이벤트리스너 제거
    - 돔 요소에 연결된 이벤트 리스너는 해당 요소가 사라져도 메모리에 남아있을 수 있음
    - 따라서 이벤트 사용이 끝난 후 반드시 리스너 제거해야함
      - → 바닐라자바스크립트에서 했을때 이런데 그럼 리액트에서는 어떻게 하지 ?
  - 타이머 제거
    - 타이머는 제거되지않으면 메모리 누수를 일으킬수 있기에 clearInterval / clearTimeout 사용
  - 순환참조 피하기
    - 객체간 순환참조는 서로를 참조하기에 메모리에서 제거되지않을 수 있기에 순환참조를 피하는 것이 가장 좋고 해야한다면 사용후 꼭 제거
  - 클로저 주의

    - 클로저는 외부함수의 변수를 참조할 수 있으므로 사용이 끝난 후에도 메모리에 남아있을 수 있음

      - 클로저란?
        - 외부함수에 접근할 수 있는 내부함수
      - 클로저 예시는?

        ```jsx
        function createCounter() {
          let count = 0;

          return function () {
            return count++;
          };
        }

        const counter = createCounter();

        console.log(counter()); // 0
        console.log(counter()); // 1
        console.log(counter()); // 2
        ```

      - 클로저에서 메모리 누수를 방지하려면?
        - **명시적으로 참조 끊기**: 클로저가 더 이상 필요하지 않을 때, 참조된 변수나 객체에 **`null`** 또는 **`undefined`**를 할당하여 명시적으로 참조를 끊을 수 있습니다.

- WeakMap, WeakSet VS Map, Set

  - Map vs WeakMap:
    Map은 키-값 쌍을 저장합니다.
    WeakMap은 객체를 키로 사용하며, 키에 대한 참조가 약하게 유지됩니다. 따라서 가비지 컬렉션의 대상이 될 수 있습니다.
  - Set vs WeakSet:
    Set은 중복되지 않는 값을 저장합니다.
    WeakSet은 객체만을 값으로 저장하며, 저장된 객체에 대한 참조가 약하게 유지됩니다. 이 또한 가비지 컬렉션의 대상이 될 수 있습니다.

- [자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식(카카오엔터)](https://fe-developers.kakaoent.com/2022/220519-garbage-collection/)
