# 📆 날짜: 2023-09-19, 2023-09-20

## 🎯 공통 질문: 깊은복사 vs 얕은복사

### 나라's 답변:

얕은복사, 깊은복사를 말하기 전 JavaScript에서 참조타입을 복사하는 것 부터 말씀드리겠습니다.
Javascript에서 참조타입을 복사를 진행한 대상은 새로운 주소값을 가지고 내부 값들은 원본값의 주소값을 할당합니다.
이런 현상을 "얕은 복사"라고 말합니다.
얕은 복사를 진행한 대상은 값의 수정이 이뤄질 때 원본 객체의 값 또한 같이 수정이 됩니다. 이 같은 현상을 방지하기 위해 "깊은 복사"라는 개념이 등장했습니다.
"깊은 복사"는 복사한 대상을 메모리에 할당합니다. 하여 복사 객체를 수정해도 원본 객체 값이 수정이 되지 않습니다.

---

### 슬기's 답변:

---

## 데이터를 복사하는 방식에 따라 깊은 복사 혹은 얕은 복사가 될 수 있습니다. <br/>값을 복사하면 복사한 값이 원본값의 주소값을 참조하면 얕은 복사, 새로운 주소값을 가지게되면 깊은복사라고 할 수 있습니다. <br/> 그렇기에 얕은 복사를 사용하면 복사된 값을 변경하면 원본값이 변경될 수 있어 깊은복사를 사용할 때도 있습니다. <br/>얕은 복사 방법에는 주로 ... 스프레드 연산자를 사용하는 방식, Object.assign()을 이용하는 방식이 있습니다. <br/>깊은 복사의 방식에는 lodash라는 라이브러리를 이용해서 deep clone으로 깊은 복사를 할 수있습니다. JSON.parse(), JSON.stringify()를 이용해서도 깊은 복사를 할 수 있다하지만, JS와 JSON의 데이터 타입이 완벽히 같지않아 단순한 객체나 배열에서는 잘 동작하지만, 함수, Date 객체와 같은 것에서는 완벽한 깊은복사가 될 수 없다고 알고있습니다.

## 🔗 슬기's 꼬리질문 : 왜 복사에대해 공부를 할 때 참조타입을 먼저 알아보셨나요?

### 나라's 답변 :

얕은복사와 깊은복사에서 공통점은 값을 복사한다는 것이라고 생각했습니다. 이때 참조타입이 복사가 이뤄질 때 얕은복사가 실시되는 것을 먼저 소개한 뒤 이후 얕은복사의 단점인 원본 객체가 수정되고 이를 해결하기위해 깊은 복사가 등장했다 라는 식으로 순서대로 공부하기 위해서 참조타입의 복사를 먼저 공부했었습니다.

### 슬기's 답변 :

복사를하면, 새로운 메모리에 값이 할당될 때 주소값을 참조하는지 새로운 값을 생성하는지를 먼저 생각하여 참조타입을 먼저 공부해보았습니다.

## 🔗 슬기's 꼬리질문 : 자바스크립트의 데이터타입을 말해주세요

### 나라's 답변 :

자바스크립트의 데이터타입에는 원시타입과 참조타입이 있습니다.
원시타입은 number, string, undefined, null, boolean, symbol, bigint 타입이 존재하며,
참조타입에는 function, Array, Object, date 등이 존재합니다.

### 슬기's 답변 :

자바스크립트의 데이터 타입에는 크게 primitive types와, Objects 타입이 있습니다.
세부적으로 primitive type에는 String, Number, BigInt, Boolean, Undefined, Null, Symbol,
Object타입에는 Object, Array, Date, RegExp, Function가 있습니다.

## 🔗 슬기's 꼬리질문 : 스프레드 연산자는 어떤 복사죠?

### 나라's 답변 :

스프레드 연산자는 배열 또는 객체를 복사할 때 얕은복사가 이뤄집니다.

### 슬기's 답변 :

스프레드 연산자는 대표적인 얕은복사의 방법입니다.
객체나 배열의 최상위 속성만 복사되며, 내부 객체는 참조로 연결됩니다.

## 🔗 슬기's 꼬리질문 : 깊은복사의 필요성을 느낀적이 있었나요?, 진짜 깊은 복사를 해야하는 상황을 겪어보셨나요?

### 나라's 답변 :

프로젝트를 진행할 때 특정 객체를 활용할 때 수정이 이뤄지면 안되는 것을 알게 되었습니다.

### 슬기's 답변 :

사용자의 프로필 정보를 편집하는 웹 페이지에서 사용자가 정보를 수정하게 되면, "취소" 버튼을 눌렀을 때 원래의 프로필 정보로 되돌릴 필요가 있었습니다. 원본 프로필 정보를 얕은 복사로 다른 변수에 저장했을 때, 사용자가 수정하는 정보가 원본 정보에도 영향을 미쳤습니다. 이 문제를 해결하기 위해 깊은 복사를 사용하여 원본 프로필 정보를 별도로 저장하였습니다.

## 🔗 슬기's 꼬리질문 : 어떤 방식으로 깊은복사를 사용하셨나요?

### 나라's 답변 :

라이브러리인 lodash에서 deepClone을 사용하여 깊은복사를 진행했었습니다.

### 슬기's 답변 :

위의 문제를 해결하기 위해 lodash 라이브러리의 cloneDeep 함수를 사용하여 깊은 복사를 수행했습니다.

먼저, 사용자의 원본 프로필 정보를 페이지 로드 시 lodash의 cloneDeep 함수를 사용하여 별도의 변수에 저장했습니다. 그리고 사용자가 프로필 정보를 수정한 후 "취소" 버튼을 클릭하면, 저장된 복사본을 이용하여 원래의 프로필 정보로 복구하였습니다.

## 🔗 슬기's 꼬리질문 : lodash에서 deep clone 을 이용해서 깊은복사를 공부하셨다하셨는데, 실제 예시 상황을 말씀해주세요.

### 나라's 답변 :

```javascript
const _ = require("lodash");

let obj = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 3,
    },
  },
  f: [4, 5, 6],
};

let clonedObj = _.cloneDeep(obj);

console.log(clonedObj); // {a: 1,b: {c: 2,d: {e: 3,},},f: [4, 5, 6]}
console.log(clonedObj.b.d === obj.b.d); // false
```

### 슬기's 답변 :

위 질문과 동일함 그렇기에 코드로 설명

```jsx
import cloneDeep from 'lodash/cloneDeep';

// 사용자의 원본 프로필 정보
const userProfile = {
  name: '슬기',
  age: 29,
  address: {
    city: '서울',
    zipcode: '12345'
  }
};

// 깊은 복사를 사용하여 원본 프로필 정보를 backupProfile에 저장합니다.
const backupProfile = cloneDeep(userProfile);

// 사용자의 프로필 정보를 수정합니다.
userProfile.name = '나라';
userProfile.address.city = '부산';

console.log(userProfile); // { name: '나라', age: 29, address: { city: '부산', zipcode: '12345' } }
console.log(backupProfile); // { name: '슬기', age: 29, address: { city: '서울', zipcode: '12345' } }

// "취소" 버튼을 클릭했을 때 원래의 프로필 정보로 복구합니다.
if (/* 사용자가 "취소" 버튼을 클릭 */) {
  userProfile = cloneDeep(backupProfile);
}
// 사용자의 프로필 정보를 수정합니다.
userProfile.name = '유한나라';
userProfile.address.city = '부산';

console.log(userProfile); // { name: '유한나라', age: 29, address: { city: '부산', zipcode: '12345' } }
console.log(backupProfile); // { name: '슬기', age: 29, address: { city: '서울', zipcode: '12345' } }

// "취소" 버튼을 클릭했을 때 원래의 프로필 정보로 복구합니다.
if (/* 사용자가 "취소" 버튼을 클릭 */) {
  userProfile = cloneDeep(backupProfile);
}
```

## 나라's 꼬리질문: lodash를 사용할 때 주의해야할 점이 있을까요?

### 나라's 답변 :

외부라이브러리를 가져와서 사용하는 것이기 때문에 해당 라이브러리를 사용하기 때문에 보안적 문제나 라이브러리 상 문제가 생겼을 때 발생되는 사이드 이펙트가 있을 것이라고 예상됩니다.

### 슬기's 답변 :

외부 패키지를 import 해서 사용하는 것이기에 번들 크기 및 성능상에 이슈가 있을 수 있다 판단됩니다.

## 나라's 꼬리질문: 얕은복사를 할 경우 객체의 프로토타입까지 복사가 되나요?

### 나라's 답변 :

얕은 복사를 진행 할 경우 객체의 프로토타입까지는 복사가 안된다고 알고있습니다. 단 복사된 객체는 원본 객체와 동일한 프로토타입을 참조합니다.

### 슬기's 답변 :

객체의 프로토타입은 복사되지않습니다.
얕은복사 또한 one level deep만큼은 복사를 하고 그 내부를 참조하는것이기에 복사된 객체가 원본 객체와 동일한 프로토타입을 참조하게됩니다.

#### 슬기's 꼬리꼬리질문 : 프로토타입까지 포함하여 객체를 복사하고자 할 때 어떤 방법을 사용할 수 있을까요?

##### 슬기's 답변 :

Object.create를 사용하여 주어진 프로토타입을 가진 새로운 객체를 생성하고, Object.assign을 사용하여 원본 객체의 속성들을 복사된 객체에 할당하는 것은 프로토타입까지 복사하는 방식을 사용하면 됩니다.

## GPT's 꼬리질문 : 깊은 복사와 얕은 복사의 성능적 차이는 무엇인가요?

### 나라's 답변 :

깊은 복사는 상대적으로 얕은복사보다 더 깊은 레벨을 복사하기 때문에 시간적인 부분과 메모리적인 부분에서 더 많은 사용을 요구할 것이라고 생각합니다.

### 슬기's 답변 :

먼저 깊은 복사를 하게되면 새로운 주소값을 생성하기에 더 많은 메모리를 사용할 수 밖에없습니다. 반면 얕은 복사는 기존 주소값을 참조하는 방식이기에 메모리 성능 면에서 이점이 있습니다.

## GPT's 꼬리질문 : 깊은 복사를 수행할 때 순환 참조(circular reference)가 있는 객체를 복사하려고 하면 어떤 문제가 발생할까요?

### 나라's 답변 :

순환참조가 있는 객체를 복사할 때는 무한루프에 빠질 수 있다고 생각합니다. 객체안에서 이미 참조가 이뤄지는 것을 복사하려면 무한정으로 해당 참조를 복사하는 과정이 생길 것이라고 생각하기 때문입니다.
또한 이런 무한루프에 빠진다면 콜 스택이 오버되는 스택오버플로오류까지 예상됩니다.

### 슬기's 답변 :

깊은 복사를 수행할 때 순환 참조가 있는 객체를 복사하려고 하면 무한 루프에 빠져서 스택 오버플로우(stack overflow) 에러가 발생할 수 있다고 알고있습니다.

---

#### REFERENCE

##### 나라

- 순환참조하는 객체를 복사하는 법
  [https://lazydev.gatsbyjs.io/javascript/different-ways-to-copy-objects-in-js/]

- \_cloneDeepWith 예제들..
  [https://lodash.com/docs/4.17.15#cloneDeep]

##### 슬기

- Json 에서 (함수와같은) 없는타입에서 깊은복사를 하면 어떻게 되지?

  - ```js
    const obj = {
      a: 10,
      b: function () {
        console.log("Hello");
      },
    };

    const copiedObj = JSON.parse(JSON.stringify(obj));

    console.log(copiedObj); // { a: 10 }
    ```

    -> 위 예시에서 볼 수 있듯이, copiedObj에는 함수 b가 포함되어 있지 않음

- JS type 과 JSON type 설명

  - JavaScript
    -Primitive Types : Number, Bigint, String, Boolean, Undefined, Null, Symbol
    -Objects : Object,Array

  - JSON
    - Number, String, Boolean, Array, Object, null

- 순환 참조란?
  두개이상의 객체나 변수가 서로를 참조하는 상황입니다.

  ```
  let objA = {};
  let objB = { refToA: objA };
  objA.refToB = objB;
  ```

  예를 들어 ,objA = {} 빈 객체이고 , objB ={refToA : objA} 일 경우 objA.refToB = objB 이렇게 되면 objA 는 objB를 참조하고 objB는 objA를 참조하는 서로가 서로를 참조하는 상황을 의미합니다.
  이러한 순환참조는 메모리누수, 깊은복사시 무한루프에 빠질 수 있고, 데이터가 복잡하여 예기치못한 버그의 원인이 될 수 있습니다.
  따라서 순환참조는 피하고 필요한 경우에는 명확하게 관리해야합니다.

- 순환참조의 필요상황은?
  예를들어 양방향 연관관계가 있을 경우 부모가 자식을 참조하고 각 자식이 다시 부모를 참조하는 경우가 있고, 그래프구조에서 노드 사이의 관계를 표현할 때 필요할수있으며, 캐시를 구현 할 때 순환참조를 의도적으로 사용할 수 있습니다.

- 스택오버플로우 에러
  프로그램의 스택 메모리 영역이 넘치게 되어 발생하는 오류인데, 원인은 각 프로그램이 한정된 메모리를 할당 받으나 그 할당된 메모리가 스택 메모리의 한계를 초과하였을지만 계속해서 데이터를 저장하려할때 프로그램이 중지되는 오류입니다.
  주로 재귀함수에서 종료조건이 없거나 무한루프가 돌 때 발생합니다.

- [[SSU몰세미나] 자바스크립트로 살펴보는 얕은 복사와 깊은 복사 (정명준)](youtube.com/watch?v=ur5A49htfwg)
  - 제일 도움이 많이 되었던 영상
- [{즉문즉설:자바스크립트} Object의 깊은 복사 vs 얕은 복사
  ](https://www.youtube.com/watch?v=QFIfI8MIURQ)

---
