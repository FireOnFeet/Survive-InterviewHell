# 📆 날짜: 2023-09-19, 2023-09-20

## 🎯 공통 질문: 깊은복사 vs 얕은복사

### 나라's 답변:

---

## <!-- 답변 -->

### 슬기's 답변:

---

## 데이터를 복사하는 방식에 따라 깊은 복사 혹은 얕은 복사가 될 수 있습니다. <br/>값을 복사하면 복사한 값이 원본값의 주소값을 참조하면 얕은 복사, 새로운 주소값을 가지게되면 깊은복사라고 할 수 있습니다. <br/> 그렇기에 얕은 복사를 사용하면 복사된 값을 변경하면 원본값이 변경될 수 있어 깊은복사를 사용할 때도 있습니다. <br/>얕은 복사 방법에는 주로 ... 스프레드 연산자를 사용하는 방식, Object.assign()을 이용하는 방식이 있습니다. <br/>깊은 복사의 방식에는 lodash라는 라이브러리를 이용해서 deep clone으로 깊은 복사를 할 수있습니다. Json.parse(), Json.stringify()를 이용해서도 깊은 복사를 할 수 있다하지만, JS와 JSON의 데이터 타입이 완벽히 같지않아 단순한 객체나 배열에서는 잘 동작하지만, 함수, Date 객체와 같은 것에서는 완벽한 깊은복사가 될 수 없다고 알고있습니다.

## 🔗 슬기's 꼬리질문 : 왜 복사에대해 공부를 할 때 참조타입을 먼저 알아보셨나요?

### 나라's 답변 :

### 슬기's 답변 :

복사를하면, 새로운 메모리에 값이 할당될 때 주소값을 참조하는지 새로운 값을 생성하는지를 먼저 생각하여 참조타입을 먼저 공부해보았습니다.

## 🔗 슬기's 꼬리질문 : 자바스크립트의 데이터타입을 말해주세요

### 나라's 답변 :

### 슬기's 답변 :

자바스크립트의 데이터 타입에는 크게 primitive types와, Objects 타입이 있습니다.
세부적으로 primitive type에는 String, Number, BigInt, Boolean, Undefined, Null, Symbol,
Object타입에는 Object, Array, Date, RegExp, Function가 있습니다.

## 🔗 슬기's 꼬리질문 : 스프레드 연산자는 어떤 복사죠?

### 나라's 답변 :

### 슬기's 답변 :

스프레드 연산자는 대표적인 얕은복사의 방법입니다.
객체나 배열의 최상위 속성만 복사되며, 내부 객체는 참조로 연결됩니다.

## 🔗 슬기's 꼬리질문 : 깊은복사의 필요성을 느낀적이 있었나요?, 진짜 깊은 복사를 해야하는 상황을 겪어보셨나요?

### 나라's 답변 :

### 슬기's 답변 :

사용자의 프로필 정보를 편집하는 웹 페이지에서 사용자가 정보를 수정하게 되면, "취소" 버튼을 눌렀을 때 원래의 프로필 정보로 되돌릴 필요가 있었습니다. 원본 프로필 정보를 얕은 복사로 다른 변수에 저장했을 때, 사용자가 수정하는 정보가 원본 정보에도 영향을 미쳤습니다. 이 문제를 해결하기 위해 깊은 복사를 사용하여 원본 프로필 정보를 별도로 저장하였습니다.

## 🔗 슬기's 꼬리질문 : 어떤 방식으로 깊은복사를 사용하셨나요?

### 나라's 답변 :

### 슬기's 답변 :

위의 문제를 해결하기 위해 lodash 라이브러리의 cloneDeep 함수를 사용하여 깊은 복사를 수행했습니다.

먼저, 사용자의 원본 프로필 정보를 페이지 로드 시 lodash의 cloneDeep 함수를 사용하여 별도의 변수에 저장했습니다. 그리고 사용자가 프로필 정보를 수정한 후 "취소" 버튼을 클릭하면, 저장된 복사본을 이용하여 원래의 프로필 정보로 복구하였습니다.

## 🔗 슬기's 꼬리질문 : lodash에서 deep clone 을 이용해서 깊은복사를 공부하셨다하셨는데, 실제 예시 상황을 말씀해주세요.

### 나라's 답변 :

### 슬기's 답변 :

위 질문과 동일함 그렇기에 코드로 설명

```jsx
import cloneDeep from 'lodash/cloneDeep';

// 사용자의 원본 프로필 정보
const userProfile = {
  name: '슬기',
  age: 29,
  address: {
    city: '서울',
    zipcode: '12345'
  }
};

// 깊은 복사를 사용하여 원본 프로필 정보를 backupProfile에 저장합니다.
const backupProfile = cloneDeep(userProfile);

// 사용자의 프로필 정보를 수정합니다.
userProfile.name = '나라';
userProfile.address.city = '부산';

console.log(userProfile); // { name: '나라', age: 29, address: { city: '부산', zipcode: '12345' } }
console.log(backupProfile); // { name: '슬기', age: 29, address: { city: '서울', zipcode: '12345' } }

// "취소" 버튼을 클릭했을 때 원래의 프로필 정보로 복구합니다.
if (/* 사용자가 "취소" 버튼을 클릭 */) {
  userProfile = cloneDeep(backupProfile);
}
// 사용자의 프로필 정보를 수정합니다.
userProfile.name = '유한나라';
userProfile.address.city = '부산';

console.log(userProfile); // { name: '유한나라', age: 29, address: { city: '부산', zipcode: '12345' } }
console.log(backupProfile); // { name: '슬기', age: 29, address: { city: '서울', zipcode: '12345' } }

// "취소" 버튼을 클릭했을 때 원래의 프로필 정보로 복구합니다.
if (/* 사용자가 "취소" 버튼을 클릭 */) {
  userProfile = cloneDeep(backupProfile);
}
```

## 나라's 꼬리질문: lodash를 사용할 때 주의해야할 점이 있을까요?

### 나라's 답변 :

### 슬기's 답변 : 외부 패키지를 import 해서 사용하는 것이기에 번들 크기 및 성능상에 이슈가 있을 수 있다 판단됩니다.

## 나라's 꼬리질문: 얕은복사를 할 경우 객체의 프로토타입까지 복사가 되나요?

### 나라's 답변 :

### 슬기's 답변 :

객체의 프로토타입은 복사되지않습니다.
얕은복사 또한 one level deep만큼은 복사를 하고 그 내부를 참조하는것이기에 복사된 객체가 원본 객체와 동일한 프로토타입을 참조하게됩니다.

#### 슬기's 꼬리꼬리질문 : 프로토타입까지 포함하여 객체를 복사하고자 할 때 어떤 방법을 사용할 수 있을까요?

##### 슬기's 답변 :

Object.create를 사용하여 주어진 프로토타입을 가진 새로운 객체를 생성하고, Object.assign을 사용하여 원본 객체의 속성들을 복사된 객체에 할당하는 것은 프로토타입까지 복사하는 방식을 사용하면 됩니다.

## GPT's 꼬리질문 : 깊은 복사와 얕은 복사의 성능적 차이는 무엇인가요?

### 나라's 답변 :

### 슬기's 답변 :

먼저 깊은 복사를 하게되면 새로운 주소값을 생성하기에 더 많은 메모리를 사용할 수 밖에없습니다. 반면 얕은 복사는 기존 주소값을 참조하는 방식이기에 메모리 성능 면에서 이점이 있습니다.

## GPT's 꼬리질문 : 깊은 복사를 수행할 때 순환 참조(circular reference)가 있는 객체를 복사하려고 하면 어떤 문제가 발생할까요?

### 나라's 답변 :

### 슬기's 답변 :

깊은 복사를 수행할 때 순환 참조가 있는 객체를 복사하려고 하면 무한 루프에 빠져서 스택 오버플로우(stack overflow) 에러가 발생할 수 있다고 알고있습니다.

---

#### REFERENCE

##### 나라

<!-- 답변 -->

##### 슬기

- Json 에서 (함수와같은) 없는타입에서 깊은복사를 하면 어떻게 되지?

  - ```js
    const obj = {
      a: 10,
      b: function () {
        console.log("Hello");
      },
    };

    const copiedObj = JSON.parse(JSON.stringify(obj));

    console.log(copiedObj); // { a: 10 }
    ```

    -> 위 예시에서 볼 수 있듯이, copiedObj에는 함수 b가 포함되어 있지 않음

- JS type 과 Json type 설명

  - JavaScript
    -Primitive Types : Number, Bigint, String, Boolean, Undefined, Null, Symbol
    -Objects : Object,Array

  - JSON
    - Number, String, Boolean, Array, Object, null

- 순환 참조란?
  두개이상의 객체나 변수가 서로를 참조하는 상황입니다.

  ```
  let objA = {};
  let objB = { refToA: objA };
  objA.refToB = objB;
  ```

  예를 들어 ,objA = {} 빈 객체이고 , objB ={refToA : objA} 일 경우 objA.refToB = objB 이렇게 되면 objA 는 objB를 참조하고 objB는 objA를 참조하는 서로가 서로를 참조하는 상황을 의미합니다.
  이러한 순환참조는 메모리누수, 깊은복사시 무한루프에 빠질 수 있고, 데이터가 복잡하여 예기치못한 버그의 원인이 될 수 있습니다.
  따라서 순환참조는 피하고 필요한 경우에는 명확하게 관리해야합니다.

- 순환참조의 필요상황은?
  예를들어 양방향 연관관계가 있을 경우 부모가 자식을 참조하고 각 자식이 다시 부모를 참조하는 경우가 있고, 그래프구조에서 노드 사이의 관계를 표현할 때 필요할수있으며, 캐시를 구현 할 때 순환참조를 의도적으로 사용할 수 있습니다.

- 스택오버플로우 에러
  프로그램의 스택 메모리 영역이 넘치게 되어 발생하는 오류인데, 원인은 각 프로그램이 한정된 메모리를 할당 받으나 그 할당된 메모리가 스택 메모리의 한계를 초과하였을지만 계속해서 데이터를 저장하려할때 프로그램이 중지되는 오류입니다.
  주로 재귀함수에서 종료조건이 없거나 무한루프가 돌 때 발생합니다.

---
