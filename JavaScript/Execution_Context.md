# 📆 날짜: 2023-09-25, 2023-09-26, 2023-10-01

## 🎯 공통 질문: 실행 컨텍스트란 무엇인가요?

### 나라's 답변:

---

## 실행할 코드에 제공할 환경정보들을 모아놓은 객체

### 슬기's 답변:

---

## 실행컨텍스트란 코드를 실행하기 위해 필요한 정보들을 한 곳에 모아둔 객체를 의미합니다.

## 🔗 나라's 꼬리질문 : 콜 스택이란 무엇인가요?

### 나라's 답변:

javascript엔진에서 사용되어지는 데이터 구조이며 함수가 호출되었을 때 FILO형태로 스택에 맨 위로 push되어지고 실행이 완료된다면 pop이 되는 형식입니다.

### 슬기's 답변:

콜 스택은 함수의 호출을 기록하는 자료구조입니다. 즉 다시말하자면 현재 실행 중인 함수의 정보를 담고 있는 자료구조입니다.
함수 가 호출되면 해당 함수의 실행 컨텍스트가 콜 스택의 맨 위에 푸시되고, 함수의 실행이 완료되면 해당 실행 컨텍스트는 스택에서 pop되어 제거됩니다.

## 🔗 나라's 꼬리질문 : 실행 컨텍스트에서 담기는 정보는 어떤것들이 있나요?

### 나라's 답변:

실행 컨텍스트에는 Variable Environment, LexicalEnvironment, ThisBinding들의 객체들이 존재합니다.

### 슬기's 답변:

VariableEnvironment, LexicalEnvironment, thisBinding이 있습니다.

## 🔗 나라's 꼬리질문 : VariableEnvironment란?, outerEnvironmentReference란 무엇일까요?

### 나라's 답변:

VariableEnvironment는 함수가 실행되었을 때 최초의 정보들을 수집하며 이 중 environmentRecord, outerEnvironmentReferece등이 있습니다.
이때 추후 변경되는 내용들은 V.E에 업데이트 되지 않습니다.

### 슬기's 답변:

VariableEnvironment란 실제로 초기 실행 컨텍스트의 변수, 함수 선언 등의 정보를 담고 있습니다. 오직 식별자 정보를 수집하는 것에 이용됩니다. outerEnvironmentReference란 현재 컨텍스트 바깥의 환경을 참조합니다. 이 참조를 통해 스코프체인이 형성됩니다. 이 체인에 의해 변수나 함수를 찾을 때 찾아가게됩니다.

## 🔗 나라's 꼬리질문 : LexicalEnvironment란?

### 나라's 답변:

VariableEnvrironment의 복사본이고 실행 컨텍스트의 정보를 담고있으며 변경되는 내용들이 업데이트되는 특징이 있습니다.

### 슬기's 답변:

LexicalEnvironment란 현재 코드 블록의 식별자 정보를 담고 있으며, 코드 실행 도중 변수의 값이 변경될 때 실시간으로 업데이트 됩니다.

## 🔗 나라's 꼬리질문 : ThisBinding이란?

### 나라's 답변:

실행 컨텍스트가 생성될 때 this의 값을 결정해주며 이 값은 컨텍스트 안에서 this가 참조할 객체를 결정합니다.

### 슬기's 답변:

실행 컨텍스트의 한 부분으로 현재 실행되고 있는 코드블록 내 this 키워드가 어떤 객체를 참조는지를 결정합니다.

## 🔗 나라's 꼬리질문 : 스코프란 무엇인가요?

### 나라's 답변:

식별자에 대한 유효범위라고 생각합니다. let, const, class등으로 선언한 대상들은 함수 블록스코프를 가지며 이외의 종류는 함수 스코프를 가집니다.

### 슬기's 답변:

스코프는 실행 컨텍스트에 의해 만들어지며 변수, 함수, 객체 등의 식별자가 유효하게 참조될 수 있는 영역을 의미합니다. 즉, 스코프는 식별자의 생존 범위와 접근성을 결정합니다.

#### 슬기's 꼬리질문 : 자바스크립트의 스코프 두가지 유형에 대해 설명해주세요.

##### 슬기's 답변 :

크게는 전역 스코프와 지역스코프로 나누어집니다.
전역 스코프는 전역 변수와 같이 코드의 모든 영역에서 접근 가능한 식별자를 포함하며
반대로 지역 스코프는 특정 코드 블럭 내에서만 접근 가능합니다.

### 🔗 슬기's 꼬리질문 : 스코프 체인이란 무엇인가요?

### 나라's 답변:

현 스코프 내에서 참조할 수 없을 때 외부 컨텍스트를 참조하게됩니다. 이런 행위를 스코프 체인이라하며 이때 참조하는 값은 outerEnvironmentReference입니다.

### 슬기's 답변:

스코프 체인이란 outerEnvironmentReference에 의해 만들어지며, 가장 가까운 자기 자신으로부터 유효한 값을 찾고, 만약 찾고자하는 값이 없을 경우 자기자신으로 부터 점점 멀리있는 범위의 값으로 부터 탐색하여 스코프를 찾아가는 것을 말합니다.

## 🔗 나라's 꼬리질문 : 호이스팅에 대해서 설명해주세요

### 나라's 답변:

실행 컨텍스트가 생성될 때 변수, 함수선언이 최상단으로 끌어올려지는 것처럼 보여 호이스팅이라 부르며 코드 실행전 변수, 함수선언을 저장합니다.

### 슬기's 답변:

호이스팅이란 말 그대로 끌어올려지는 것 같은 현상을 의미합니다. 자바스크립트 엔진에서 코드를 해석하고 실행할 때 발생하는 특성입니다.
실행컨텍스트에 의해 VariableEnvironment에 식별자 정보를 실행컨텍스트의 맨 위로 끌어올리는 것을 의미합니다. 그렇기에 코드 내에서 변수나 함수를 선언하기 전에 참조하거나 호출하여도 에러가 발생하지 않는 특징을 갖습니다.

#### 슬기's 꼬리질문 : 변수호이스팅과 함수호이스팅에 대해 설명해주세요.

##### 슬기's 답변 :

변수 호이스팅과 함수 호이스팅은 JavaScript에서 코드의 실행 전에 메모리에 식별자 정보를 저장하는 과정에서 발생하는 현상입니다.
변수 호이스팅이란 var 로 선언된 변수는 호이스팅 되나 초기화는 호이스팅 되지않아 Undefined로 초기화 되며 let, const로 호이스팅 될 경우 변수는 호이스팅 되나 초기화가 되지않아 선언 전 참조하려면 referenceError가 발생합니다.
함수호이스팅은 함수 선언이 호이스팅되며 해당 함수의 내용도 함께 호이스팅 되는것을 의미합니다.

## 🔗 나라's 꼬리질문 : 함수선언문, 표현식의 차이점을 설명해주세요

### 나라's 답변:

함수 선언문은 선언시 호이스팅이 이뤄지며 선언되기전에 호출이 가능합니다. 그리고 함수의 이름이 필수요소로 작용합니다.
함수 표현식은 변수에 함수를 할당하는 방식으로 호이스팅에 영향을 받지않으며 함수가 선언된 이후에만 호출이 가능합니다.

### 슬기's 답변:

자바스크립트에서 함수를 정의하는 두가지 주요방법입니다.
함수 선언문은 function 키워드로 함수의 이름을 사용하여 직접 함수를 선언하는 방식을 의미하며 함수 전체가 호이스팅되어 선언 전에 함수를 호출할 수 있습니다.
함수 표현식은 변수에 함수를 할당하여 함수를 정의하는 방식으로 변수 선언은 호이스팅이 되나 함수 내용은 호이스팅 되지않기에 선언 전에 함수를 호출하면 typeError가 발생합니다.

## 🔗 슬기's 꼬리질문 : 실행 컨텍스트가 왜 필요한가요?

### 나라's 답변:

실행 컨텍스트는 변수와 함수를 선언하고 관리하는 데에 있어서 필요하며 해당 요소들의 정보를 가지고있어서 데이터에 접근할 수 있게 해줍니다.
또한 스코프를 결정하여 레이어에 맞는 정보를 제공하는 등 JavaScript를 실행허고 추적하는 데에 있어 필수적인 역할을 합니다.

### 슬기's 답변:

자바스크립트에서 함수가 실행되기 위해 필요한 정보를 미리 수집해놓고 업데이트 해 놓는 과정을 실행컨텍스트를 통해서 이루어집니다. 이 실행컨텍스트 내의 스코프 체인을 통해 현재 실행중인 코드의 스코프 및 주변 스코프를 탐색할 수 있고, 코드 실행 순서를 관리 할 수 있기에 실행컨텍스트가 필요하다 생각됩니다.

## 🔗 슬기's 꼬리질문 : 자바스크립트 엔진은 소스코드를 어떤 단계로 처리되나요?

### 나라's 답변:

소스코드를 로딩하여 해당 소스코드를 컴파일링과정을 거칩니다. 이후 컴파일된 코드를 기준으로 실행컨텍스트를 생성하며 코드를 실행시킵니다. 이후 실행이 끝났다면 G.C에 의해서 사용되지 않는 객체들은 사라집니다.

### 슬기's 답변:

평가와 실행 단계로 이루어집니다.
먼저 평가단계에서 소스코드를 읽어두고 변수와 함수 선언들을 호이스팅으로 메모리에 올라가고,
실행 단계에서 실제 코드를 순차적으로 실행하며 이 과정에서 변수에 값들이 할당되거나 호출되는 과정을 겪게됩니다.

## 🔗 슬기's 꼬리질문 : var let const 차이는?

### 나라's 답변:

var, let , const는 모두 JavaScript에서 변수를 선언하게하는 키워드입니다.
var같은 경우 함수스코프를 가지며 호이스팅이 가능하여 선언 전에 해당변수를 사용할 수 있습니다.
하지만 값에 선언과 할당이 따로 진행되기 때문에 값 할당 이전에 접근한다면 undefined를 반환합니다. 또한 동일한 스코프에서는 변수를 재선언이 가능합니다.

let은 블록스코프를 가지며 호이스팅이 가능합니다. 하지만 var와 다른점은 선언전에 접근한다면 ReferenceError를 출력합니다. 이를 TDZ라고 부릅니다.
let은 동일 스코프에서 변수를 재선언할 수 없고 값을 재할당하는 것은 가능합니다.

const는 블록스코프를 가지며 호이스팅이 가능하비만 let과 마찬가지로 선언전에 접근한다면 ReferenceError를 출력합니다.
const는 변수를 재선언, 재할당이 모두 불가능합니다. 이때 객체를 const로 선언했다면 객체의 속성은 변경이 가능합니다.

### 슬기's 답변:

var, let , const 모두 변수를 선언하는 키워드입니다.
var 의 경우 함수 레벨의 스코프를 가지며, 선언이 호이스팅되어 undefined로 초기화됩니다.
let, const의 경우 블록 레벨 스코프를 가지며 선언은 호이스팅 되지만 초기화는 따로 이루어 지지않아 선언 전 변수를 참조하려하면 ReferenceError가 발생하게됩니다.
let과 const의 주요 차이점은 let은 재할당이 가능하며 const는 상수와 같이 변하지 않는 값을 할당 할 때 사용합니다.

## 🔗 GPT's 꼬리질문 : 실행 컨텍스트가 생성되는 3가지 주요 상황은 무엇인가요?

### 나라's 답변:

함수를 호출하고 실행할 때, 전역 컨텍스트가 생성될 때, eval함수가 실행될 때라고 말할 수 있습니다.

### 슬기's 답변:

전역컨텍스트, 함수 컨텍스트, 모듈 컨텍스트 이렇게 크게 3가지 상황이 실행 컨텍스트가 생성되는 주요한 상황이며, 각 실행 컨텍스트는 실행중인 코드에 필요한 모든 정보를 포함하며 해당 코드가 실행되는 동안 유효합니다.

## 🔗 GPT's 꼬리질문 : 클로저란 무엇이며, 실행 컨텍스트와 어떻게 관련되어 있나요?

### 나라's 답변:

클로저란 내부함수에서 외부함수에 변수에 접근을 하였을 때 외부함수의 실행이 끝났음에도 변수에 참조가 계속일어나는 것을 말합니다.
이때 실행컨텍스트에서 외부함수로 참조를 하기에 스코프체인을 이용하게됩니다. 또한 대개 함수의 실행이 완료되면 해당 함수의 실행컨텍스트는 메모리에서 제거되게 되는데 클로저 같은경우 참조가 유지되고있기에 메모리에서 제거되지않습니다.

### 슬기's 답변:

클로저란 외부함수의 변수를 참조할수 있는 내부함수를 의미하며
외부함수의 실행 컨텍스트가 종료된 후에도 해당 변수에 접근이 가능합니다.
outerEnvironmentReference 가 외부 함수의 환경을 참조하기 때문입니다.

## 🔗 GPT's 꼬리질문 : 글로벌 실행 컨텍스트와 함수 실행 컨텍스트의 차이점은 무엇인가요?

### 나라's 답변:

우선 글로벌 실행컨텍스트가 함수실행컨텍스트보다 먼저 생성되는 것, 함수 실행 컨텍스트에서 스코프체인을 통해 외부 변수에 접근하는 것에서 최종적인 경로가 글로벌 실행컨텍스트인 것이 차이가 있습니다.

### 슬기's 답변:

전역실행컨텍스트와 함수실행 컨텍스트는 코드가 실행되는 환경을 제공하며
전역컨텍스트의 경우 스크립트가 시작 될 때 생성되며, 코드 실행되는 동안 유지가 됩니다. 또한 전역 변수와 함수를 포함하여 어디서든 접근이 가능하며 this 는 전역객체를 참조합니다.
함수컨텍스트의 경우 함수가 호출될 때마다 생성되며, 해당 함수 내부에서 선언된 지역변수와 매개변수를 포함하며 함수 외부에서는 접근할 수 없으며 함수 호출 방식에 따라 this의 값이 결정됩니다.

---

#### REFERENCE

##### 나라

코어자바스크립트

[Variable Object](https://techwell.wooritech.com/docs/languages/javascript/execution-context/)

##### 정리

- 실행 컨텍스트 : "실행할 코드에 제공할 환경정보들을 모아놓은 객체"
  - 실행컨텍스트가 생성되는 상황
    - 전역 컨텍스트 실행, eval함수 실행, 함수 실행
  - 실행 컨텍스트에서의 객체 종류
    - Variable Environment
      - environment Record
      - outerEnvironmentReference
      - 최초 실행시 스냅샷을 유지합니다 (e.R, oER..)
      - 이후 변경점을 저장하지 않습니다.
    - Lexical Environment
      - V.E의 복사본
      - 이후 변경점이 업데이트됩니다.
    - ThisBinding
      - this로 지정된 객체가 저장됩니다.
  - 호이스팅
    - 스코프 안에서 변수, 함수 선언을 최상단으로 끌어올려 해석한다고 하여 "호이스팅"이라고 부름
    - 함수 선언식으로 작성된 함수는 선언단계에서 호이스팅이 이뤄지고 동시에 초기화가 이뤄짐, 이후 값을 할당한다.
  - 스코프
    - 식별자의 유효범위
    - 변수, 함수를 접근할 때 현 컨텍스트 안에서 없다면 outerEnvironmentReference를 통해서 스코프체인이 이뤄져서 필요한 조건을 찾음.
  - 클로저
    - 함수 내부에서 특정 변수를 외부에서 참조할 때 해당 변수가 사라지지않는 현상

##### 슬기

- 컨텍스트 : 해당 코드의 배경이되는 조건 / 환경
- 실행 컨텍스트 : 코드를 실행하는데 필요한 배경이되는 조건 / 환경

- 스택
  - 제일 먼저 들어온것이 제일 마지막에 빠지는 개념
- 콜스택
  - 코드실행에 관여하는 스택
  - 현재 어떤 함수가 동작중인지 다음에 어떤함수가 호출될 예정인지를 제어하는 자료구조
- VariableEnvironment, LexicalEnvironment : 현재 환경과 관련된 식별자 정보들

- VariableEnvironment : 오직 식별자 정보를 수집하는데 사용됨

- LexicalEnvironment : 어휘적 / 사전적 환경
  - 각 식별자의 데이터를 추적하는 용도
    - environmentRecord
      - 현재 문맥의 식별자 정보
      - 호이스팅 : 식별자 정보를 실행컨텍스트의 맨 위로 끌어올림
    - outerEnvironmentReference
      - 외부환경에대한 참조
      - 스코프 체인 : outerEnvironmentReference 에 의해서 만들어짐
        - 가장 가까운 자기 자신부터 점점 멀리있는 스코프로 찾아나가는것
        - 외부로는 나갈수 있는데 자기보다 안쪽으로는 접근할 수 없다!
        - 스코프 : 변수의 유효범위
          - 변수의 유효범위는 실행컨텍스트가 만드는것임
          - 실행컨텍스트가 수집해놓은 정보만 접근할 수 있고 그 변수는 실행컨텍스트 내부에서만 존재함

변수의 값들의 변화가 생기면, LexicalEnvironment 에만 실시간으로 반영됨

- 그럼 가비지 컬렉션에서 클로저의 개념은 어떻게되지?
  클로저와 가비지 컬렉션은 자바스크립트의 메모리 관리에 있어 중요한 개념들입니다. 클로저와 가비지 컬렉션의 관계를 이해하기 위해서는 참조와 생명 주기의 개념을 이해해야 합니다.
  클로저는 내부 함수가 외부 함수의 지역 변수에 접근할 수 있게 해줍니다. 이 때문에 외부 함수의 실행 컨텍스트가 종료된 후에도 내부 함수가 외부 함수의 변수를 참조하고 있으면 그 변수는 메모리에서 해제되지 않습니다.
  즉, 클로저는 변수의 생명 주기를 연장시킵니다.
  그러나 클로저에 의해 참조되지 않는 모든 변수나 객체는 가비지 컬렉션의 대상이 됩니다. 가비지 컬렉터는 주기적으로 더 이상 사용되지 않는 변수나 객체를 찾아 메모리에서 해제합니다.
  클로저의 문제점 중 하나는 과도하게 사용될 경우 메모리 누수를 일으킬 수 있다는 것입니다. 클로저에 의해 참조되는 외부 함수의 변수가 계속 메모리에 남아 있기 때문입니다. 이 문제를 방지하기 위해서는 클로저를 적절하게 사용하고, 더 이상 필요하지 않은 클로저는 참조를 끊어주어야 합니다.
  요약하면, 클로저는 외부 함수의 변수를 참조하여 그 생명 주기를 연장시키지만, 클로저에 의해 참조되지 않는 변수나 객체는 가비지 컬렉션의 대상이 됩니다. 클로저의 과도한 사용은 메모리 누수의 원인이 될 수 있으므로 주의해야 합니다.

---
