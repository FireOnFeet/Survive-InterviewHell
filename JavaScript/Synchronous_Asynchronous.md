# 📆 날짜: 2023-10-04

## 🎯 공통 질문: 동기와 비동기에 대해 설명해주세요

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: 동기와 비동기는 프로그래밍에서 데이터 처리 혹은 함수의 실행 방식을 나타냅니다. 동기 방식은 한 작업이 완료될 때까지 기다린 후, 그 다음 작업을 순차적으로 실행합니다. 반면 비동기 방식은 특정 작업의 완료를 기다리지 않고, 다른 작업들과 병렬로 실행할 수 있습니다.

## 🔗 꼬리질문: javascript에서 콜백함수는 어떻게 작동하나요?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: 자바스크립트에서 콜백함수는 특정 작업이나 이벤트가 완료된 후에 실행되도록 설계된 함수를 의미합니다. 함수의 파라미터로 다른 함수를 전달하고 그 전달된 함수를 나중에 호출하기에 비동기 작업을 위해 사용됩니다.

#### 🔗🔗 나라's 꼬리질문: 콜백 지옥을 어떻게 개선할 수 있나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 콜백지옥이란 비동기 프로그래밍시 발생되는 문제로서 함수의 매개 변수로 넘겨지는 콜백 함수가 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 말합니다. 개선하기 위해서는 promise 혹은 async, await 을 이용하여 좀 더 간단하게 비동기 프로그래밍을 할 수 있습니다.

#### 🔗🔗 GPT's 꼬리질문: 콜백 함수의 장단점은 무엇인가요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 간단하게 사용할 수 있고 특정 작업이 완료된 직후 실행할 로직을 정의하기에 제어 흐름이 유연하다는것이 장점입니다. 반면, 콜백이 계속 중첩되다 보면 콜백 지옥이라는 문제가 발생됩니다. 코드의 가독성이 떨어지고 오류처리가 복잡하여 코드 흐름을 읽기 어려워 유지보수가 어렵다는 단점이 있습니다.

## 🔗 꼬리질문: javascript에서 promise에 대해서 설명해주세요

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: 프로미스는 자바스크립트에서 비동기 연산을 더 효율적으로 다루기 위한 객체입니다. 프로미스는 Pending, Fulfilled, Rejected 라는 3가지의 상태를 가지며 then, catch, finally와 같은 메서드를 사용하여 성공했을 때, 실패했을 때, 항상 호출될 콜백함수를 지정할 수 있어 비동기 코드의 가족성과 유지보수성을 향상시킬 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: Promise의 장단점을 말해주세요

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 장점은 콜백함수를 사용했을 때 보다 훨씬 깔끔한 코드 구조로 가독성이 좋고, catch를 통한 오류 처리로 효율적이며 진행 상태를 명시적으로 가진다는 장점이있습니다. 반면 단점은 간단한 콜백으로 될 수 있는 코드를 좀더 복잡하게 구현될 수 있다는 단점을 가집니다.

#### 🔗🔗 슬기's 꼬리질문: promise.all 에 대해 아시나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 여러개의 프로미스들의 배열을 받아 모든 프로미스들이 완료될때까지 기다린 다음 그 결과를 배열로 반환하는 메서드입니다. 결과 순서를 보장하며, 하나라도 거부되면 전체가 거부된다는 특징을 갖습니다.

#### 🔗🔗 GPT's 꼬리질문: promise.then과 promise.catch의 차이점은 무엇인가요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: then 은 성공했을 경우 실행할 콜백을, catch는 실패하였을 경우의 콜백을 의미합니다

## 🔗 꼬리질문: Async Await이란 무엇입니까?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: Async Await이란 자바스크립트에서 비동기 프로그래밍을 더 간결하고 가독성 좋게 처리하기위한 문법입니다. async 키워드를 사용하면 해당 함수는 항상 프로미스를 반환하게되고 await을 통해 프로미스가 처리될 때 까지 함수의 실행을 일시 중지합니다. 그렇기에 프로미스의 결과를 마치 동기처럼 할 수 있습니다.

#### 🔗🔗 슬기's 꼬리질문: async 선언 후 await을 안하면 어떻게되나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: async로 선언된 함수 내에서 await를 사용하지 않으면, 해당 함수는 기본적으로 일반 함수처럼 동기적으로 작동합니다. 그러나 함수의 반환 값은 항상 Promise로 감싸집니다. 만약, await 없이 비동기 연산을 시작한다면 해당 연산의 완료를 기다리지않고 다음 코드를 실행하기에 비동기적으로 계속실행되는 동안 함수는 즉시 Promise를 반환합니다.

#### 🔗🔗 GPT's 꼬리질문: try-catch와 async-await을 어떻게 함께 사용하나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: try-catch 구문은 오류를 캐치하고 처리합니다. await로부터 발생할 수 있는 오류를 잡아줍니다.

## 🔗 꼬리질문: 이벤트 루프는 어떻게 동작하나요?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: 자바스크립트는 싱글스레드 언어이기에 이벤트루프를 통해 비동기 작업이 가능하게 됩니다. 자바스크립트 엔진은 코드를 위에서 아래로 실행되며 동기적인 코드들이 콜 스택에 쌓이며 즉시 실행 되며 비동기 함수가 호출되면 그 함수는 콜백 큐에 넣어집니다. 현재 실행중인 함수가 모두 종료되고 콜스택이 비게되면 이벤트루프가 콜백큐에서 가장 먼저 들어온 콜백함수를 콜 스 택으로 옮겨서 실행합니다. 이런 구조로 비동기적으로 작업을 처리할 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: javascript의 비동기 처리에서 마이크로 테스크와 매크로 테스크의 차이는 무엇일까요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 마이크로 태스크와 매크로 태스크 큐에 들어가는 함수의 종류가 다릅니다 promise와 같은것은 마이크로 태스크큐에 들어가고 setTimeout, setInterval과 같은 타이머 함수는 매크로 태스크큐에 들어갑니다.마이크로 태스크큐에 있는것이 매크로태스크큐보다 우선순위가 높아 콜스택이 비어있다면 우선순위는 마이크로태스크큐가 비어있는지를 먼저 보게됩니다.

#### 🔗🔗 GPT's 꼬리질문: Task Queue와 Web API는 이벤트 루프와 어떻게 연관되어 있나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 이벤트루프의 주 역할이 콜스택과 태스크큐가 비어있는지를 지속적으로 확인하는 것입니다. 콜스택에서 비동기함수가 Web API 로 이동하게 되고 WebAPI를 통해 백그라운드에서 실행하게 되며 비동기 처리가 끝난 후Task Queue에 넣어집니다.

#### 🔗🔗 GPT's 꼬리질문: Web Workers는 무엇이며, 어떻게 동기/비동기 문제를 해결하는데 도움을 주나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: <!-- 답변 -->

## 🔗 나라's 꼬리질문: javascript는 비동기를 어떻게 구현하나요?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: 자바스크립트에서 비동기를 구현하는 방식에는 크게 3가지 방식이있습니다. callback, promise, async await이 있습니다. 간결하게 작업하기위해서는 callback을 사용하고 조금 더 가독성을 높이기 위해서 promise 객체를 사용하여 상태를 명확히 할수있으며 async await을 함께 사용하여 비동기 함수를 동기적인것 처럼 코드를 구현할 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: javascript 비동기 코드에서는 에러 핸들링을 어떻게 할까요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: catch 를 이용해서, 혹은 try catch 구문으로 에러 핸들링을 할 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: 비동기 예시를 하나 만들어주세요

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 자바스크립트에서 외부 api에서 데이터를 가져오는 작업은 네트워크 지연, 서버응답시간과 같은 이유로 시간이 걸릴수 있기에 비동기적으로 처리해야합니다.

#### 🔗🔗 나라's 꼬리질문: 비동기 처리에서 race condition에 대해서 설명해주세요

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: 레이스 컨디션이란 두개 이상의 비동기 연산이 서로 앞서려는 경쟁 상황을 의미하며 이로인해 예상치 못한 결과가 발생할 수 있습니다.이런 예상치 못한 결과를 방지하기위해서는 한 자원에 동시에 사용하지 못하도록 락이 걸려야 하며 순차적으로 실행되도록 코드를 구현해야합니다.

## 🔗 슬기's 꼬리질문: 동기 / 비동기 , 블럭킹 / 논블럭킹의 차이에 대해 설명해주세요

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: 동기 작업은 순차적으로 실행되고 블로킹될 수 있으며, 비동기 작업은 순차적으로 실행되지 않고 블로킹되지 않습니다. 블로킹과 논블로킹은 작업의 흐름과 제어에 영향을 미치며, 비동기 작업은 논블로킹 특성을 가짐으로써 다른 작업들과 독립적으로 실행될 수 있습니다.

#### 🔗🔗 GPT's 꼬리질문: 실제 개발 환경에서 블럭킹 코드와 논블럭킹 코드의 차이를 체감할 수 있는 예를 들 수 있나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: <!-- 답변 -->

## 🔗 GPT's 꼬리질문: 비동기 처리를 왜 사용하나요? 그리고 언제 동기 처리를 선택해야 하나요?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: 자바스크립트는 싱글스레드 언어이기에, 좀더 자원을 효울적으로 사용하기위해 , 성능향상을 위해 사용됩니다. 하지만 무조건적으로 비동기를 하는것은아니고 작업의 순서가 중요할 경우, 단순로직의 경우 동기적인 코드를 구현하게됩니다.

## 🔗 GPT's 꼬리질문: Fetch API를 사용할 때 비동기 요청을 어떻게 다루나요?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: Fetch는 자바스크립트에서 네트워크 요청을 보내기 위한 인터페이스이며, 기본적으로 Promise를 반환하기 때문에 then을 이용하여 비동기 요청을 수행할 수 있고 async await으로 비동기 코드를 동기코드처럼 작성할 수 있습니다.

## 🔗 GPT's 꼬리질문: setTimeout과 setInterval에 대해 설명하고, 어떻게 비동기적으로 동작하는지 설명해주세요.

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: setTimeout과 setInterval은 자바스크립트에서 제공하는 내장 타이머 함수입니다. 이 함수들을 주어진 시간이 지난 후 특정 작업을 수행하도록 예약할 수 있습니다. setTimeout은 한번만 실행되며 setInterval의 경우 주어진 시간마다 반복적으로 실행되는 특징이있습니다. 이 두 함수를 호출하면 브라우저의 WebAPI가 지정된 시간동안 타이머를 설정하고 타이머가 완료되면 콜백 함수는 콜백큐에 추가 되며 이벤트루프에의해 비동기적으로 처리됩니다.

#### 🔗🔗 GPT's 꼬리질문: setTimeout의 콜백이 정확히 설정한 시간 후에 실행된다는 보장이 있나요?

##### 나라's 답변: <!-- 답변 -->

##### 슬기's 답변: setTimeout의 콜백이 정확히 설정한 시간 후에 실행된다는 보장은 없습니다. 설정한 시간은 최소 지연 시간으로 간주되며, 실제 콜백 함수가 실행되기까지의 시간은 더 길어질 수 있습니다.

## 🔗 GPT's 꼬리질문: Debounce와 Throttle 기법은 무엇이며, 어떻게 비동기 이벤트 처리에 활용되나요?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: Debounce와 Throttle은 주로 연속적인 이벤트를 효율적으로 처리하기 위한 기법입니다. 불필요한 함수호출을 최소화하여 성능최적화에 도움을 줄 수 있습니다. Debounce 의 경우 마지막 호출된 후 일정 시간 동안 다시 호출되지 않을 때 해당함수를 실행하며 Throttle은 함수 호출을 일정한 주기로 제한하는 기법입니다.

## 📝 REFERENCE

### 나라

<!-- 답변 -->

### 슬기

[비동기처리는 무조건 async/await 아닌가요?](https://www.youtube.com/watch?v=Z1zHOh45NDU)

[Block vs Non-Block & Sync vs Async](https://www.youtube.com/watch?v=IdpkfygWIMk&t=17s)

[멍토의 Blocking vs Non-Blocking, Sync vs Async](https://www.youtube.com/watch?v=oEIoqGd-Sns&t=1s)

[카일의 프론트엔드의 비동기](https://www.youtube.com/watch?v=fsmekO1fQcw)

[Promise 정리: async/await 사용법 & then과의 차이](https://one-it.tistory.com/entry/Promise-%EC%A0%95%EB%A6%AC-asyncawait-%EC%82%AC%EC%9A%A9%EB%B2%95-then%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4)

- 동기 & 비동기 → 다른 프로세스와 함께 움직이냐(동기) 다른 프로세스가 언제 결과를 가져오든 별 관심이 없냐(비동기)
  동기는 요청을 보낸 뒤 결과를 받아야 그 다음 작업을 수행하는 순차적 방식을 뜻합니다.
  비동기는 요청 작업을 하면 그 작업에 대한 결과를 받는 것과 상관없이 바로 다음 작업을 수행하는 비순차적 방식입니다.
  여러 함수들이 시간에 맞춰 함께 움직이면 동기, 그렇지 않으면 비동기입니다.
  요청받은 함수가 작업을 완료했는지를 누가 체크하냐의 차이로, 시간 관점에 해당한다.
  동기식이면 상대방이 작업을 끝낸 직후와 동시에 해당 결과물을 받아와 곧바로 진행한다. 이 말인즉, 상대방이 작업을 끝냈는지 계속해서 체크한다는 말. 그러다 상대방이 작업 끝내면 해당 결과물을 받아와 동시에 start한다.
  비동기면 상대방이 작업을 끝냈는지 아닌지 별 관심이 없다. 다했는지 체크하지 않고 관심 끈 채로 내 할일 계속 한다. 그러다 상대방이 결과물을 가져오더라도 그걸 받는 즉시 수행하는 게 아니라 작업 순서에 넣어놓고 있다가(자바스크립트의 경우 콜백에 넣는다) 때가 되면 시작한다. 상대방의 결과 반환과 그에 대응하는 내 작업의 시작이 동기화되어 있지 않다는 말.
- 블록킹 & 논블록킹 →제어권을 곧바로 돌려받냐 아니냐의 차이
  블로킹은 요청자 함수가 응답자 함수에게 제어권을 주냐 아니면 제어권을 줬다가 곧바로 회수하냐와 같은 작업 주체로서의 관점이 다른 것을 말합니다.
  **요청받은 함수가 cpu 제어권(함수 실행권)을 언제 넘겨주냐의 차이로, 작업(제어권) 관점**에 해당한다.
  블로킹이면 CPU 제어권은 요청자가 갖게 되며, 응답자는 요청자의 작업이 끝날 때까지 계속 대기해야 한다.
  논 블로킹이면 CPU 제어권을 넘겨주자마자 곧바로 돌려받는다.
