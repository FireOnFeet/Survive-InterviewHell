# 📆 날짜: 2023-10-04

## 🎯 공통 질문: 동기와 비동기에 대해 설명해주세요

### 나라's 답변: 동기란 일이 순차적으로 실행되는 방식을 말하고 비동기란 비순차적으로 일을 비순차적으로 실행되는 방식을 뜻합니다. JavaScript에서 동기적 처리를 하는 예시는 Generate함수가 있으며 비동기처리 예시는 Callback함수, Promise, Async/Await이 있습니다.

### 슬기's 답변: 동기와 비동기는 프로그래밍에서 데이터 처리 혹은 함수의 실행 방식을 나타냅니다. 동기 방식은 한 작업이 완료될 때까지 기다린 후, 그 다음 작업을 순차적으로 실행합니다. 반면 비동기 방식은 특정 작업의 완료를 기다리지 않고, 다른 작업들과 병렬로 실행할 수 있습니다.

## 🔗 꼬리질문: javascript에서 콜백함수는 어떻게 작동하나요?

### 나라's 답변: JavaScrip에서의 콜백함수는 함수를 다른 함수의 매개변수에 전달하고 특정 이벤트가 발생했을 때 전달되었는 함수를 호출하는 방식으로 작동합니다. 이때 특정 이벤트를 지정하지 않는다면 비동기적으로 작동하지않습니다. 그러므로 콜백함수를 비동기적으로 사용할 의도가 있다면 특정 이벤트를 지정해야합니다.

### 슬기's 답변: 자바스크립트에서 콜백함수는 특정 작업이나 이벤트가 완료된 후에 실행되도록 설계된 함수를 의미합니다. 함수의 파라미터로 다른 함수를 전달하고 그 전달된 함수를 나중에 호출하기에 비동기 작업을 위해 사용됩니다.

### 🔗🔗🔗나라's 꼬리질문 : 콜백함수가 다른 함수의 매개변수로 전달되는 이유를 설명해주세요

JavaScript에서의 함수는 1급객체로 취급되며 1급객체의 특성에 따라 매개변수로 함수를 넘길 수 있습니다.

### 🔗🔗🔗🔗나라's 꼬리의 꼬리질문 : 그럼 1급객체란 무엇일까요?

1급객체란 특정 기준을 모두 충족한 객체를 말하며 해당 기준은 1. 변수에 할당이 가능해야한다. 2. 다른 함수를 인자에 전달받는다. 3. 함수의 결과값으로 출력될 수 있어야한다. 입니다.

#### 🔗🔗 나라's 꼬리질문: 콜백 지옥을 어떻게 개선할 수 있나요?

##### 나라's 답변: 콜백지옥이란 비동기적 처리의 깊이가 깊어지면서 콜백함수 안에 또 함수호출이 반복되어지는 패턴을 말합니다. 이때 일반적으로 Promise 객체나 async/await을 사용할 수 있습니다.

##### 슬기's 답변: 콜백지옥이란 비동기 프로그래밍시 발생되는 문제로서 함수의 매개 변수로 넘겨지는 콜백 함수가 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 말합니다. 개선하기 위해서는 promise 혹은 async, await 을 이용하여 좀 더 간단하게 비동기 프로그래밍을 할 수 있습니다.

#### 🔗🔗🔗 나라's의 꼬리질문 : Promise객체, async/await말고도 콜백지옥을 해결할 방법은 없을까요?

비동기적 처리를 해야할 함수를 각각 독립적으로 작성하여 해결할 수 있습니다. 예를 들어 1번 함수를 호출하고 이후 2번, 3번을 호출이 되어야한다면 콜백함수를 중첩하는 것이 아니라 1번함수, 2번함수, 3번함수를 선언후 각 번호함수마다 호출이 완료된다면 다음 번호함수를 호출하도록 작성할 수 있습니다.

#### 🔗🔗 GPT's 꼬리질문: 콜백 함수의 장단점은 무엇인가요?

##### 나라's 답변: 특정 이벤트가 실행되는 시점에 따라 함수를 호출할 수 있는 장점이 있지만 특정 이벤트가 없다면 비동기적 처리가 안되며 비동기 작업이 중첩되어 생긴다면 콜백지옥에 빠질 수 있습니다.

##### 슬기's 답변: 간단하게 사용할 수 있고 특정 작업이 완료된 직후 실행할 로직을 정의하기에 제어 흐름이 유연하다는것이 장점입니다. 반면, 콜백이 계속 중첩되다 보면 콜백 지옥이라는 문제가 발생됩니다. 코드의 가독성이 떨어지고 오류처리가 복잡하여 코드 흐름을 읽기 어려워 유지보수가 어렵다는 단점이 있습니다.

## 🔗 꼬리질문: javascript에서 promise에 대해서 설명해주세요

### 나라's 답변: 콜백만으로 비동기적 처리를 함에 한계가 있어 ES6에 등장한 문법이며 Promise 체인을 통하여 콜백지옥을 해결할 수 있으며 보다 가독성이 뛰어나는 문법입니다.

### 슬기's 답변: 프로미스는 자바스크립트에서 비동기 연산을 더 효율적으로 다루기 위한 객체입니다. 프로미스는 Pending, Fulfilled, Rejected 라는 3가지의 상태를 가지며 then, catch, finally와 같은 메서드를 사용하여 성공했을 때, 실패했을 때, 항상 호출될 콜백함수를 지정할 수 있어 비동기 코드의 가족성과 유지보수성을 향상시킬 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: Promise의 장단점을 말해주세요

##### 나라's 답변: Promise는 Promise체인을 통해 가독성을 높이고 여러 비동기 작업에 편리합니다. catch메서드를 통해서 에러핸들링에 장점이 있습니다, 또한 Promise는 내부상태 pending, fullfilled, rejected를 통해 흐름을 쉽게 가져갈 수 있습니다. 단점은 내부상태가 한번 결정된다면 이후 변경이 불가능하다는 단점이 있습니다.

##### 슬기's 답변: 장점은 콜백함수를 사용했을 때 보다 훨씬 깔끔한 코드 구조로 가독성이 좋고, catch를 통한 오류 처리로 효율적이며 진행 상태를 명시적으로 가진다는 장점이있습니다. 반면 단점은 간단한 콜백으로 될 수 있는 코드를 좀더 복잡하게 구현될 수 있다는 단점을 가집니다.

#### 🔗🔗 슬기's 꼬리질문: promise.all 에 대해 아시나요?

##### 나라's 답변: 여러 Promise객체를 비동기적으로 실행하게 합니다. 인자로 Promise배열을 받으며 여러 Promise요소들이 모두 처리된다면 새로운 Promise를 반환합니다.

##### 슬기's 답변: 여러개의 프로미스들의 배열을 받아 모든 프로미스들이 완료될때까지 기다린 다음 그 결과를 배열로 반환하는 메서드입니다. 결과 순서를 보장하며, 하나라도 거부되면 전체가 거부된다는 특징을 갖습니다.

#### 🔗🔗🔗 나라's 꼬리질문 : 만약 promise.all을 실행 중 하나가 실패한다면 어떻게 될까요?

Promise.all의 전체 실행이 멈추며 결과는 무시됩니다. 이와같은 결과를 해결하기위해 .race메서드가 있습니다. race메서드는 받은 Promise배열중 가장 먼저 처리된 결과를 반환하고 만약 실패한다면 해당 실패에 대한 에러를 가진 결과를 반환해줍니다.

#### 🔗🔗 GPT's 꼬리질문: promise.then과 promise.catch의 차이점은 무엇인가요?

##### 나라's 답변: then메서드는 Promise가 성공되었을 때 호출되며 체이닝을 통해 새로운 Promise객체를 반환합니다. 하지만 .catch 메서드는 Promise가 실패한 경우 호출되는 메서드입니다. 대개 에러핸들링을 위해서 사용되어집니다.

##### 슬기's 답변: then 은 성공했을 경우 실행할 콜백을, catch는 실패하였을 경우의 콜백을 의미합니다

## 🔗 꼬리질문: Async Await이란 무엇입니까?

### 나라's 답변: 비동기적 처리를 할 때 사용되며 함수선언부 앞에 async를 사용하며 async를 사용한 함수는 항상 Promise값을 반환합니다. Promise 사용하는 앞부분에 await을 추가하여 사용합니다.

### 슬기's 답변: Async Await이란 자바스크립트에서 비동기 프로그래밍을 더 간결하고 가독성 좋게 처리하기위한 문법입니다. async 키워드를 사용하면 해당 함수는 항상 프로미스를 반환하게되고 await을 통해 프로미스가 처리될 때 까지 함수의 실행을 일시 중지합니다. 그렇기에 프로미스의 결과를 마치 동기처럼 할 수 있습니다.

#### 🔗🔗 슬기's 꼬리질문: async 선언 후 await을 안하면 어떻게되나요?

##### 나라's 답변: 비동기적 작업을 하지 않고 바로 Promise를 반환합니다

##### 슬기's 답변: async로 선언된 함수 내에서 await를 사용하지 않으면, 해당 함수는 기본적으로 일반 함수처럼 동기적으로 작동합니다. 그러나 함수의 반환 값은 항상 Promise로 감싸집니다. 만약, await 없이 비동기 연산을 시작한다면 해당 연산의 완료를 기다리지않고 다음 코드를 실행하기에 비동기적으로 계속실행되는 동안 함수는 즉시 Promise를 반환합니다.

#### 🔗🔗 GPT's 꼬리질문: try-catch와 async-await을 어떻게 함께 사용하나요?

##### 나라's 답변: 비동기 작업이 필요한 함수 선언부에 async, Promise를 사용하는 부분에 await를 추가합니다 이때 await을 실행하는 블럭을 try코드로 감싸고 이후 catch로 에러핸들링을 실행합니다.

##### 슬기's 답변: try-catch 구문은 오류를 캐치하고 처리합니다. await로부터 발생할 수 있는 오류를 잡아줍니다.

## 🔗 꼬리질문: 이벤트 루프는 어떻게 동작하나요?

### 나라's 답변: 이벤트 루프는 브라우저에서 제공하는 기능 중 하나이며 Javascript에서 콜스택을 계속 주시하고 콜 스택이 비어있다면 task queue에서 작업을 실행시킵니다.

### 슬기's 답변: 자바스크립트는 싱글스레드 언어이기에 이벤트루프를 통해 비동기 작업이 가능하게 됩니다. 자바스크립트 엔진은 코드를 위에서 아래로 실행되며 동기적인 코드들이 콜 스택에 쌓이며 즉시 실행 되며 비동기 함수가 호출되면 그 함수는 콜백 큐에 넣어집니다. 현재 실행중인 함수가 모두 종료되고 콜스택이 비게되면 이벤트루프가 콜백큐에서 가장 먼저 들어온 콜백함수를 콜 스 택으로 옮겨서 실행합니다. 이런 구조로 비동기적으로 작업을 처리할 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: javascript의 비동기 처리에서 마이크로 테스크와 매크로 테스크의 차이는 무엇일까요?

##### 나라's 답변: 가장 큰 차이점은 마이크로 테스크가 매크로 테스크보다 우선순위가 높다는 점입니다. 마이크로 테스크는 Promise, async function이 대표적인 예시이며 매크로 테스크에서는 rAF, setTimeout등이 예시가 됩니다.

##### 슬기's 답변: 마이크로 태스크와 매크로 태스크 큐에 들어가는 함수의 종류가 다릅니다 promise와 같은것은 마이크로 태스크큐에 들어가고 setTimeout, setInterval과 같은 타이머 함수는 매크로 태스크큐에 들어갑니다.마이크로 태스크큐에 있는것이 매크로태스크큐보다 우선순위가 높아 콜스택이 비어있다면 우선순위는 마이크로태스크큐가 비어있는지를 먼저 보게됩니다.

#### 🔗🔗 GPT's 꼬리질문: Task Queue와 Web API는 이벤트 루프와 어떻게 연관되어 있나요?

##### 나라's 답변: Task Queue같은 경우 테스크 큐에 한 종류이며 이전 설명과 같이 이벤트루프에 의해서 콜 스택에 추가되어 실행되게 됩니다. Web API는 브라우저에서 제공되는 API들이며 time메서드, DOM API 등이 있으며 실행되면 이벤트루프에 의해서 콜스택에 추가됩니다.

##### 슬기's 답변: 이벤트루프의 주 역할이 콜스택과 태스크큐가 비어있는지를 지속적으로 확인하는 것입니다. 콜스택에서 비동기함수가 Web API 로 이동하게 되고 WebAPI를 통해 백그라운드에서 실행하게 되며 비동기 처리가 끝난 후Task Queue에 넣어집니다.

#### 🔗🔗 GPT's 꼬리질문: Web Workers는 무엇이며, 어떻게 동기/비동기 문제를 해결하는데 도움을 주나요?

##### 나라's 답변: Web Workers는 병렬 처리를 가능하게 하는 Javascript에서의 API이며 스레드에서 독립적으로 실행되는 스크립트를 생성합니다. 이는 브라우저가 동작을 멈추지 않아서 시간이 오래 소요되는 작업을 진행할 수 있습니다.

##### 슬기's 답변: <!-- 답변 -->

## 🔗 나라's 꼬리질문: javascript는 비동기를 어떻게 구현하나요?

### 나라's 답변: callBack함수나 Async/Await, Promise를 사용하여 비동기적 로직을 작성하여 코드가 비동기적으로 동작하게 합니다.

### 슬기's 답변: 자바스크립트에서 비동기를 구현하는 방식에는 크게 3가지 방식이있습니다. callback, promise, async await이 있습니다. 간결하게 작업하기위해서는 callback을 사용하고 조금 더 가독성을 높이기 위해서 promise 객체를 사용하여 상태를 명확히 할수있으며 async await을 함께 사용하여 비동기 함수를 동기적인것 처럼 코드를 구현할 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: javascript 비동기 코드에서는 에러 핸들링을 어떻게 할까요?

##### 나라's 답변: try, catch문을 사용하여 중간에 에러가 발생하는 것을 처리할 수 있으며, Promise같은 경우 Promise.settled, .race같은 메서드로 실패할 경우 에러를 받게 할 수 있습니다.

##### 슬기's 답변: catch 를 이용해서, 혹은 try catch 구문으로 에러 핸들링을 할 수 있습니다.

#### 🔗🔗 나라's 꼬리질문: 비동기 예시를 하나 만들어주세요

##### 나라's 답변: 예를 들어 API를 사용하기 위해 비동기적으로 데이터를 요청하고 응답이 잘못되었을 때를 가정해 에러핸들링과정을 추가합니다.

##### 슬기's 답변: 자바스크립트에서 외부 api에서 데이터를 가져오는 작업은 네트워크 지연, 서버응답시간과 같은 이유로 시간이 걸릴수 있기에 비동기적으로 처리해야합니다.

#### 🔗🔗 나라's 꼬리질문: 비동기 처리에서 race condition에 대해서 설명해주세요

##### 나라's 답변: 여러개의 비동기 작업이 존재할 때 마치 경쟁하는 것처럼 작업이 중복되는 것을 말합니다. 이는 Promise, async/await을 사용하여 작업을 컨트롤 할 수 잇습니다.

##### 슬기's 답변: 레이스 컨디션이란 두개 이상의 비동기 연산이 서로 앞서려는 경쟁 상황을 의미하며 이로인해 예상치 못한 결과가 발생할 수 있습니다.이런 예상치 못한 결과를 방지하기위해서는 한 자원에 동시에 사용하지 못하도록 락이 걸려야 하며 순차적으로 실행되도록 코드를 구현해야합니다.

## 🔗 슬기's 꼬리질문: 동기 / 비동기 , 블럭킹 / 논블럭킹의 차이에 대해 설명해주세요

### 나라's 답변: 동기, 비동기는 실행순서, 완료시점에 대한 내용이라면 블럭킹, 논블럭킹은 작업 수행 중에서의 상태를 얘기하는 것 입니다.

### 슬기's 답변: 동기 작업은 순차적으로 실행되고 블로킹될 수 있으며, 비동기 작업은 순차적으로 실행되지 않고 블로킹되지 않습니다. 블로킹과 논블로킹은 작업의 흐름과 제어에 영향을 미치며, 비동기 작업은 논블로킹 특성을 가짐으로써 다른 작업들과 독립적으로 실행될 수 있습니다.

#### 🔗🔗 GPT's 꼬리질문: 실제 개발 환경에서 블럭킹 코드와 논블럭킹 코드의 차이를 체감할 수 있는 예를 들 수 있나요?

##### 나라's 답변:

...?

##### 슬기's 답변: <!-- 답변 -->

## 🔗 GPT's 꼬리질문: 비동기 처리를 왜 사용하나요? 그리고 언제 동기 처리를 선택해야 하나요?

### 나라's 답변: JavaScript는 싱글 스레드 언어로써 한번에 하나의 작업을 처리할 수 있습니다. 이때 비동기 처리를 사용을 한다면 시간이 오래 걸리는 작업을 차단하지 않고 실행할 수 있으므로 보다 빠른 작업 처리를 할 수 있습니다. 동기적 처리가 필요할 때는 인간이라면 동기적으로 실행하는 것이 이해하기 쉽기 때문에 가독성적인 부분에서 이점이 있으며 꼭 순차적으로 실행이 되어야할 경우에는 동기적 처리가 필요합니다.

### 슬기's 답변: 자바스크립트는 싱글스레드 언어이기에, 좀더 자원을 효울적으로 사용하기위해 , 성능향상을 위해 사용됩니다. 하지만 무조건적으로 비동기를 하는것은아니고 작업의 순서가 중요할 경우, 단순로직의 경우 동기적인 코드를 구현하게됩니다.

## 🔗 GPT's 꼬리질문: Fetch API를 사용할 때 비동기 요청을 어떻게 다루나요?

### 나라's 답변: Promise 또는 Async/Await을 사용할 수 있습니다. Promise는 fetch를 하고 응답을 then체이닝을 통해 응답을 받고 catch를 통해서 에러핸들링을 시도합니다. Async/Await같은 경우 fetch할 것을 async함수로 만든다음 fetch를 await을 사용하여 비동기적인 작업을 만들어서 try catch문을 활용하여 비동기적으로 요청을 합니다.

### 슬기's 답변: Fetch는 자바스크립트에서 네트워크 요청을 보내기 위한 인터페이스이며, 기본적으로 Promise를 반환하기 때문에 then을 이용하여 비동기 요청을 수행할 수 있고 async await으로 비동기 코드를 동기코드처럼 작성할 수 있습니다.

## 🔗 GPT's 꼬리질문: setTimeout과 setInterval에 대해 설명하고, 어떻게 비동기적으로 동작하는지 설명해주세요.

### 나라's 답변: setTimeout, setInterval을 통해서 컨텍스트가 만들어진다면 callback queue에 올라갑니다. 이후 일반 코드들이 콜 스택에서 호출이 되어 비어져잇다면 이벤트 루프가 콜 스택에 올려줍니다. 이런 방식으로 비동기적으로 동작합니다.

### 슬기's 답변: setTimeout과 setInterval은 자바스크립트에서 제공하는 내장 타이머 함수입니다. 이 함수들을 주어진 시간이 지난 후 특정 작업을 수행하도록 예약할 수 있습니다. setTimeout은 한번만 실행되며 setInterval의 경우 주어진 시간마다 반복적으로 실행되는 특징이있습니다. 이 두 함수를 호출하면 브라우저의 WebAPI가 지정된 시간동안 타이머를 설정하고 타이머가 완료되면 콜백 함수는 콜백큐에 추가 되며 이벤트루프에의해 비동기적으로 처리됩니다.

#### 🔗🔗 GPT's 꼬리질문: setTimeout의 콜백이 정확히 설정한 시간 후에 실행된다는 보장이 있나요?

##### 나라's 답변: Timeout에서 지정된 시간은 얼마나 지연되어야하는 지를 나타냅니다. 즉 이 지연시간이 지나간 다음에 실행이 되며 이 지연시간 중간에 다른 작업 있다면 영향을 받을 수 있습니다. 예를들어 1초 뒤에 'a'라는 것을 콘솔에 띄우게끔 setTimeout을 작성하고 for문으로 백만번을 돌린다고 할때 의도한 1초뒤에 'a'가 콘솔에 찍히지 않고 for문을 계산하는 시간까지 더한 뒤 'a'가 찍힙니다.

##### 슬기's 답변: setTimeout의 콜백이 정확히 설정한 시간 후에 실행된다는 보장은 없습니다. 설정한 시간은 최소 지연 시간으로 간주되며, 실제 콜백 함수가 실행되기까지의 시간은 더 길어질 수 있습니다.

## 🔗 GPT's 꼬리질문: Debounce와 Throttle 기법은 무엇이며, 어떻게 비동기 이벤트 처리에 활용되나요?

### 나라's 답변: Debounce란 동일한 이벤트가 반복적으로 발생한다고 할 때 "마지막 이벤트"가 발생 후 일정 시간이 지나면 이벤트를 처리하는 기법입니다. Debounce는 검색어 자동완성에 대한 기능을 구현할 때 사용되어집니다. Throttle은 일정 시간동안 이벤트 처리 함수가 한 번만 실행되도록 하는 기법입니다. 이것은 Debounce와는 다르게 일정 주기가 존재하며 일정 주기마다 이벤트를 처리합니다. Throttle은 대표적으로 스크롤 이벤트처리할 때 사용되어집니다.

### 슬기's 답변: Debounce와 Throttle은 주로 연속적인 이벤트를 효율적으로 처리하기 위한 기법입니다. 불필요한 함수호출을 최소화하여 성능최적화에 도움을 줄 수 있습니다. Debounce 의 경우 마지막 호출된 후 일정 시간 동안 다시 호출되지 않을 때 해당함수를 실행하며 Throttle은 함수 호출을 일정한 주기로 제한하는 기법입니다.

## 📝 REFERENCE

### 나라

<!-- 답변 -->

### 슬기

[비동기처리는 무조건 async/await 아닌가요?](https://www.youtube.com/watch?v=Z1zHOh45NDU)

[Block vs Non-Block & Sync vs Async](https://www.youtube.com/watch?v=IdpkfygWIMk&t=17s)

[멍토의 Blocking vs Non-Blocking, Sync vs Async](https://www.youtube.com/watch?v=oEIoqGd-Sns&t=1s)

[카일의 프론트엔드의 비동기](https://www.youtube.com/watch?v=fsmekO1fQcw)

[Promise 정리: async/await 사용법 & then과의 차이](https://one-it.tistory.com/entry/Promise-%EC%A0%95%EB%A6%AC-asyncawait-%EC%82%AC%EC%9A%A9%EB%B2%95-then%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4)

- 동기 & 비동기 → 다른 프로세스와 함께 움직이냐(동기) 다른 프로세스가 언제 결과를 가져오든 별 관심이 없냐(비동기)
  동기는 요청을 보낸 뒤 결과를 받아야 그 다음 작업을 수행하는 순차적 방식을 뜻합니다.
  비동기는 요청 작업을 하면 그 작업에 대한 결과를 받는 것과 상관없이 바로 다음 작업을 수행하는 비순차적 방식입니다.
  여러 함수들이 시간에 맞춰 함께 움직이면 동기, 그렇지 않으면 비동기입니다.
  요청받은 함수가 작업을 완료했는지를 누가 체크하냐의 차이로, 시간 관점에 해당한다.
  동기식이면 상대방이 작업을 끝낸 직후와 동시에 해당 결과물을 받아와 곧바로 진행한다. 이 말인즉, 상대방이 작업을 끝냈는지 계속해서 체크한다는 말. 그러다 상대방이 작업 끝내면 해당 결과물을 받아와 동시에 start한다.
  비동기면 상대방이 작업을 끝냈는지 아닌지 별 관심이 없다. 다했는지 체크하지 않고 관심 끈 채로 내 할일 계속 한다. 그러다 상대방이 결과물을 가져오더라도 그걸 받는 즉시 수행하는 게 아니라 작업 순서에 넣어놓고 있다가(자바스크립트의 경우 콜백에 넣는다) 때가 되면 시작한다. 상대방의 결과 반환과 그에 대응하는 내 작업의 시작이 동기화되어 있지 않다는 말.
- 블록킹 & 논블록킹 →제어권을 곧바로 돌려받냐 아니냐의 차이
  블로킹은 요청자 함수가 응답자 함수에게 제어권을 주냐 아니면 제어권을 줬다가 곧바로 회수하냐와 같은 작업 주체로서의 관점이 다른 것을 말합니다.
  **요청받은 함수가 cpu 제어권(함수 실행권)을 언제 넘겨주냐의 차이로, 작업(제어권) 관점**에 해당한다.
  블로킹이면 CPU 제어권은 요청자가 갖게 되며, 응답자는 요청자의 작업이 끝날 때까지 계속 대기해야 한다.
  논 블로킹이면 CPU 제어권을 넘겨주자마자 곧바로 돌려받는다.
