# 📆 날짜: 2023-10-13

## 🎯 공통 질문: 브라우저와 서버간 통신은 어떻게 이뤄지나요?

### 나라's 답변: 유저가 브라우저에 URL을 입력하고 보낸다면 DNS서버에 조회를 통해 IP주소를 알아냅니다. IP주소를 가지고 TCP/IP라는 전송 프로토콜을 사용하여 IP주소에 해당하는 웹 서버를 찾습니다. 이후 브라우저가 서버에 연결이 된다면 HTTP프로토콜에 통신 규칙을 따라 브라우저가 서버에게 HTTP요청을 전송합니다. 웹 서버는 요청을 받고 요청 메세지에 따라서 컨텐츠를 가져오고 응답 메세지를 생성하여 다시 클라이언트에 전송합니다. 브라우저는 서버로부터 받은 컨텐츠로 렌더링합니다.

### 슬기's 답변: 브라우저와 서버간 통신은 주로 HTTP / HTTPS를 사용하여이루어집니다. 먼저, 사용자가 브라우저에 URL을 입력하면 DNS 조회가 이루어지고, DNS로 부터 IP주소를 확인받게되면, TCP연결로 성공 시 HTTP 요청 메시지를 서버에 전송하여 서버는 요청받은 메시지를 처리 후 HTTP 응답 메시지를 전송하여 그 내용을 토대로 브라우저가 렌더링되며 TCP 연결이 종료됩니다.

### 정호's 답변: 웹 브라우저와 서버 간의 통신은 주로 HTTP를 사용합니다. 이 프로토콜은 클라이언트와 서버 간에 데이터를 주고받는 데 사용되며 브라우저에서 웹 페이지를 열면, 브라우저는 해당 웹 페이지에 대한 서버에 HTTP 요청을 보냅니다. 이 요청에는 페이지를 요청하는 데 필요한 정보가 포함되어 있습니다. 서버는 이 요청을 받고 요청된 페이지 또는 데이터를 찾아서 그에 맞는 HTTP 응답을 생성합니다. 이 응답에는 요청된 데이터와 함께 상태 코드, 헤더 등이 포함되어 있습니다. 그후 서버는 생성된 응답을 브라우저로 다시 보냅니다. 응답이 도착하면 브라우저는 해당 데이터를 해석하고 화면에 표시합니다.

TCP연결

## 3way Handshake를 설명해주세요.

## 🔗 꼬리질문: HTTP와 HTTPS는 무엇인가?

### 나라's 답변: HTTP(HyperTextTransferProtocol)은 클라이언트와 서버간의 데이터를 주고받기 위한 프로토콜입니다. HTTPS는 HTTP의 보안버전이며 HTTP를 사용할 때 데이터를 암호화하지 않은채로 전송되기에 데이터가 쉽게 탈취 될 수 있습니다. 이런 보안적 단점을 극복하기위해 HTTPS는 SSL/TLS프로토콜을 사용하여 데이터를 암호화하여 보안성을 강화한 프로토콜입니다.

### 슬기's 답변: 두 방식 모두 웹에서 데이터를 전송하기 위해 사용되는 프로토콜로, Hyper Text Transfer Protocol 은 공통되고, HTTPS 는 Secure 가 추가된 버전입니다. HTTP 는 암호화 되지 않은 상태로 데이터를 전송하기에 보안에 치명적이며, HTTPS 는 인증서를 사용하여 웹 서버의 내용을 인증합니다.

### 정호's 답변: HTTP는 "HyperText Transfer Protocol"의 약자로, 웹 브라우저와 웹 서버 간에 정보를 주고받기 위한 규약압니다. 하지만 HTTP는 정보가 평문으로 전송되기 때문에 도청 또는 데이터 변조와 같은 위험에 노출될 수 있습니다. 그래서 나타난 것이 바로 HTTPS입니다. HTTPS는 "HTTP Secure"의 약자로, 보안이 강화된 HTTP입니다. HTTPS는 일반 HTTP의 보안 결함을 보완하기 위해 SSL 또는 TSL 프로토콜을 이용해 데이터를 암호화합니다. 이렇게 하면 도청 또는 데이터 변조와 같은 공격으로부터 보호받을 수 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: 프로토콜이란?

##### 나라's 답변: 컴퓨터끼리의 데이터 교환방식을 정의하는 규칙이라고 말 할 수 있습니다.

##### 슬기's 답변: 프로토콜은 특정한 통신 규약을 의미하며, 컴퓨터나 네트워크 장치가 서로 정보를 교환할 때 필요한 규칙, 표준, 또는 규약을 의미합니다. 즉, HTTP는 HyperText를 전송하기 위한 통신 규약을 의미합니다.

##### 정호's 답변: 프로토콜은 통신을 원할하게 하기 위해 어떻게 데이터를 주고받을지에 대한 규칙과 규약의 집합입니다. 이 규칙들은 네트워크 상에서 장치들이 어떻게 소통할지, 데이터를 어떤 형식으로 보낼지, 그리고 어떤 순서로 작업을 수행할지 정의하고 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: HTTP에서 HTTPS로 요청을 보낼 수 있는가요?

##### 나라's 답변: 요청은 보낼 수 있지만 사용자가 접속할 때 보안적 측면을 위해 HTTPS로 리다이렉트를 시키는 것이 일반적인 경우입니다.

##### 슬기's 답변: 요청을 보낼 수 있습니다. 하지만, 보안을 위해 사용자가 HTTP를 통해 접속하려할 때 HTTPS로 리다이렉트시키는것이 일반적입니다.

##### 정호's 답변: 일반적으로는 CORS에러 또는 HTTPS로 리디렉션이 될 것이라고 생각됩니다. 하지만 만약 서버에서 위와 같은 작업이 진행되지 않았다면 요청이 가능하다고 생각합니다.

#### 🔗🔗 슬기's 꼬리의 꼬리의 꼬리질문: 그렇다면 HTTPS를 사용하지않고 HTTP만 사용하는 사이트들의 이유는 무엇이 있을까요?

##### 슬기's 답변: 일단, HTTPS를 사용하려면 SSL/TLS인증서가 필요하기에 비용 문제, S라는 추가적인 단계를 거쳐야하기에 설정의 복잡성 문제 혹은 읽기만 필요한 데이터 보안이 필요하지않는 사이트의 경우는 간단하게 사용하기 위해 HTTP만 사용하기도 합니다. 하지만, 그럼에도 웹사이트 보안이 중요하고 SEO측면에서도 HTTPS를 사용하는것이 더 높은 순위를 보여하기에 HTTPS를 사용하는것을 권장합니다.

#### 🔗🔗 꼬리의 꼬리질문:  대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.

##### 나라's 답변: 대칭키 방식은 서로가 같은 키를 가지고 데이터를 암호화시켜 보내고 복호화시켜 사용하는 방식입니다. 비대칭키 암호화는 암호화, 복호화 할 때 서로 다른 키를 사용하는 방법으로 하나는 공개로 다른 하나는 시크릿으로 사용합니다. 대칭키 방식은 단순 계산으로 암호화, 복호화를 진행하여 리소스를 적게사용하지만 키가 유출된다면 보안이 쉽게 뚤리게됩니다. 비대칭키 같은 경우 대칭키 방식에 비해 암호화방식이 복잡하고 속도가 상대적으로 느릴 수 있지만 그만큼 안전한 교환이 가능하고 공개키가 노출되었다고하여도 보안적으로 좋다고 말할 수 있습니다.

##### 슬기's 답변: 대칭키 암호화 방식은 암호와와 복호화에 같은(대칭)키를 사용하는 방식으로 키 관리가 간단하고 암호화와 복호화 속도가 빠르다는 장점이 있지만, 키값을 관리하는것에 문제가 생길 수 있습니다. 비대칭키 암호화 방식은 공개키 암호화 방식이라고도 하며 암호화와 복호화에 서로 다른 키를 사용하는 방식입니다. 공개키로 암호화된 데이터는 해당 공개키와 쌍을 이루는 개인키로만 복호화를 할 수 있어 더 안전한 방식이며 키 배포 문제도 해결해줄 수 있으나 속도가 상대적으로 느린 편입니다.

##### 정호's 답변: 대칭키 암호화는 하나의 키를 사용해 데이터를 암호화하고 해독합니다. 이는 송신자와 수신자가 동일한 비밀 키를 공유해야 한다는 단점이 있습니다. 예를 들어 제가 나라님에게 메시지를 보낼 때, 저는 메시지를 암호화하는데 사용한 키를 나라님과 공유해야 합니다. 이때 키가 노출되면 암호가 깨지기 때문에 대칭키 시스템은 키를 안전하게 공유하는 것이 중요합니다. 비대칭키 암호화는 공개 키와 개인 키 두개의 키를 사용합니다. 공개 키는 누구나 알 수 있지만, 해당 키로 암호화된 데이터는 개인 키로만 해독이 가능합니다. 즉, 송신자는 수신자의 공개 키를 사용해 데이터를 암호화하고, 수신자는 자신만 가지고 있는 개인 키를 사용해 데이터를 해독합니다. 해당 방법은 키를 공유하지 않아도 되기 때문에 안정성이 향상됩니다.

#### 🔗🔗 슬기's 꼬리의 꼬리의 꼬리질문: 언제 대칭키, 언제 비대칭키 암호화 방식을 사용할까요?

##### 슬기's 답변: 일반적으로 대칭키와 비대칭키 암호화는 서로 병합되어 함께 사용됩니다. 예를들어 HTTPS통신에서 처음 연결시 비대칭키 암호화 방식을 사용하여 안전하게 대칭키를 교환 하고 이후 데이터 전송은 대칭키를 사용하여 암호화 하는 방식을 사용함으로 안전성과 효율성을 모두 확보할 수 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: SSL Handshake에 대해서 설명해보세요.

##### 나라's 답변: Secure Sokets Layer로 클라이언트와 서버간의 네트워크 연결을 하는 과정을 말합니다. TCP연결이 수립되면 이후 SSL handshake를 진행하며 서로 암호화된 정보를 교환하는 것이 특징입니다. 현재는 TLS(Transport Layer Security)로 대체되어서 주로 사용됩니다. 먼저 클라이언트에서 TLS버전과 알고리즘을 결정하여 clientHello를 보냅니다. 이후 서버에서 TSL버전과 알고리즘을을 확인한 후 serverHello를 보내고 이후 공개키를 전달합니다(serverHello Done). 클라이언트는 서버의 SSL인증서를 CA(인증기관)공개 키로 복호화를 하고 시크릿키를 생성합니다. 이후 시크릿 키를 공개키로 암호화하여 보냅니다(ClientKeyExchange). 서버는 클라이언트가 보낸 공유키를 서버의 시크릿 키로 복호화하여 까봅니다. 정보 교환이 끝나고 통신이 준비가 되었다는 패킷을 보내고 Finished패킷을 보내 TLS Handshake를 종료합니다.

##### 슬기's 답변: 클라이언트와 서버는 암호화된 연결을 시작하기 위해 먼저 서로의 암호화 방식을 협상하고 인증서와 공개키를 교환하며 마지막 공유된 세션 키를 생성하여 안전한 통신을 시작합니다.

##### 정호's 답변: 클라이언트와 서버 간에 안전한 통신을 확립하기 위해 SSL/TLS 프로토콜에서 사용되는 과정 중 하나가 SSL Handshake입니다. 우선 클라이언트가 서버에게 연결을 요청하면 클라이언트는 지원하는 암호화 알고리즘과 다른 연결 관련 정보를 보냅니다. 서버는 클라이언트의 연결 관련 정보와 서버가 지원하는 암호화 알고리즘과 연결 관련 정보를 보냅니다. 서버는 클라이언트에게 자신의 디지털 인증서를 보내고, 클라이언트는 이 인증서의 유효성을 확인하고, 서버가 신뢰할 수 있는 것인지를 판단합니다. 클라이언트와 서버는 서로에게 사용할 대칭키(세션키)를 교환하기 위한 과정을 진행합니다. 이 단계에서는 공개 키 암호화가 사용됩니다. 그 후 클라이언트와 서버는 앞서 교환한 정보를 사용하여 각자 계산한 해시값을 서로에게 보냅니다. 이를 통해 상호 간의 통신이 제대로 설정됐는지를 확인합니다. 이렇게 SSL Handshake가 완료되면, 클라이언트와 서버는 안전한 통신을 위한 공유된 대칭키를 가지고, 이를 통해 메시지를 암호화 및 복호화할 수 있게 됩니다.

#### 🔗🔗 슬기's 꼬리의 꼬리의 꼬리질문: SSL, TLS에 대해 설명해주세요

##### 슬기's 답변: SSL은 Secure Sockets Layer로 웹사이트와 브라우저 사이 연결을 암호화 하는 보안 프로토콜이며 중간에서 데이터를 가로채더라도 암호화되어있기에 데이터의 무결성이 보장됩니다. TLS은 Transport Layer Security 로 SSL의 다음 버전으로 보안의 강화된 버전입니다.

#### 🔗🔗 꼬리의 꼬리질문: Request Body와 Response Body는 무엇인가요?

##### 나라's 답변: 둘 다 HTTP메세지에서의 일부이며 Request는 요청 메세지에서 사용되며 클라이언트에서 서버로 전송되는 데이터입니다. Post, put등 메서드가 사용되며 사용자 데이터, JSON객체 등이 담겨있습니다. , Response는 응답 메세지에서 사용되며 서버가 클라이언트의 요청에 대한 결과 데이터를 Response Body에 담아 전송합니다.

##### 슬기's 답변: Request Body와 Response Body는 HTTP 요청과 응답 메시지의 구성 요소 중 하나입니다. Request Body는 클라이언트가 서버로 데이터를 전송할때 주로 PUT, POST, PATCH와 같은 메서드를 요청하는 방식을 포함해서 보내며 Response Body는 서버가 해당 패지의 HTML, CSS, JavaScript등 필요한 정보를 보내는것을 의미합니다.

##### 정호's 답변: Request Body는 클라이언트가 서버에게 보내는 데이터를 말합니다. 예를 들자면 일반적으로 사용자가 로그인 폼에서 입력한 데이터는 Request Body에 담겨서 서버에 전달됩니다. Response Body는 서버가 클라이언트에게 보내는 데이터를 말합니다. 이 데이터는 HTML 페이지, JSON 형식의 데이터, 이미지 등이 될 수 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: 요청을 할 때 GET을 사용하는 이유는 무엇인가요?

##### 나라's 답변: get은 요청을 캐싱할 수 있기 때문에 한번 요청이 되었던 것이라면 이후 빠르게 불러올 수 있는 장점이 있으며 동일한 연산을 수행해도 항상 동일한 결과를 출력하는 장점이 있기에 요청시 GET을 사용한다고 생각합니다.

##### 슬기's 답변: HTTP 프로토콜 중 가장 기본적이고 자주 사용되는 요청 메시지로 데이터를 조회 할 경우 사용되며 GET요청은 무상태성의 원칙에 따라 정보를 요청할 때마다 독립적으로 작동해야 하며 GET 특성상 보안 상 민감한 데이터나 대용량 데이터 전송에는 적합하지 않아 이 경우 POST와 같은 다른 메서드를 사용하는 것이 더 적합합니다.

##### 정호's 답변: REST API 규칙에 의하면 데이터 조회는 멱등성 (같은 조건으로 요청을 했을 때 반드시 같은 값이 나와야한다)이 지켜져야하지만, Request Body를 서버에 요청할 경우 멱등성이 깨질 가능성이 있기 때문에 Request Body가 무시되는 GET 메서드를 통해 데이터 조회를 한다고 알고있습니다.

#### 🔗🔗 슬기's 꼬리의 꼬리의 꼬리질문: 무상태성의 원칙이 무엇이죠?

##### 슬기's 답변: 무상태성의 원칙은 HTTP 프로토콜이 클라이언트와 서버 간의 각 요청을 독립적으로 처리한다는 원칙을 의미합니다. 즉, 서버는 이전에 수행된 요청과 현재 수행중인 요청 사이에 관계나 정보를 저장하고 있지 않습니다. 때문에 필요한 모든 정보를 매 요청마다 보내줘야합니다.

#### 🔗🔗 슬기's 꼬리의 꼬리의 꼬리질문: 그렇다면 민감한 데이터의 경우 POST로 요청을 보내는 방식에대해 설명해주세요

##### 슬기's 답변: GET 요청과는 달리, POST 요청의 데이터는 URL에 노출되지 않기 때문에 민감한 데이터의 전송에 더 적합합니다. 하지만 POST요청만으로 완전히 데이터가 안전하다 보장할 수 없기에 중간에서 가로채면 요청 본문의 내용을 볼 수 있기에 HTTPS 와 같은 프로토콜을 사용하여 데이터를 암호화해야합니다.

#### 🔗🔗 꼬리의 꼬리질문: HTTP Method - PUT과 PATCH의 차이는 무엇인가요?

##### 나라's 답변: 두가지 다 서버에서 새로운 리소스를 추가하거나 수정할 때 사용되어지는 HTTP메서드입니다. 하지만 PUT메서드는 새로운 데이터를 추가, 수정할 때 해당 데이터의 전체 리소스를 교체하는 방식, PATCH는 리소스의 일부분만 수정할 수 있습니다.

##### 슬기's 답변: PUT과 PATCH는 리소스를 수정하는 데 사용되는 두 가지 HTTP 메서드입니다. PUT의 경우 대상 리소스 전체 교체시 사용되기에 모든 속성 정보를 전달해야하며, PATCH의 경우 해당 리소스의 일부 수정 시 사용되어 부분적인 정보를 전송하여 부분적인 변경을 할 수 있습니다.

##### 정호's 답변: PUT과 PATCH 둘 다 HTTP 메서드로, 리소스를 업데이트하기 위해 사용되지만 중요한 차이점이 있습니다. PUT은 전체 리소스를 업데이트 하는 데 사용됩니다. 클라이언트가 서버에게 새로운 데이터를 제공하면, 해당 리소스는 완전히 새로운 데이터로 교체됩니다. 하지만 PATCH를 사용할 경우 리소스의 변경된 부분만 업데이트합니다.

#### 🔗🔗 꼬리의 꼬리질문: HTTP의 버전별로 차이점을 설명해주세요.

##### 나라's 답변: HTTP 1.0에서는 여러 HTTP메서드(get, post)을 지원하게되고 HTTP헤더가 추가되었습니다. 또한 다양한 컨텐츠들(비디오, 이미지)를 전송하게 되며, 요청 이후 응답이 된다면 연결이 끝나게 했습니다. HTTP 1.1에서는 여러 요청과 응답이 이뤄질 때 자꾸 연결이 끊기는 것이 문제가 되어 연결을 지속적으로 연결을 구현했으며(keep-alive), 한번에 여러 요청을 전송하게하고 응답은 순서대로 받게했습니다. put,delete등 메서드도 추가되었습니다. 2.0에서는 HTTP메세지가 text에서 binary로 인코딩되어 전송되며 한번 커넥션이 이뤄졌을 때 응답 순서에 상관없이 메세지를 주고 받게 되었습니다. 3.0에서는 기존 통신프로토콜인 TCP방식에서 UDP기반으로 바뀌었습니다. 이는 기존 TCP방식의 연결과정(핸드쉐이크)에서 지연시간과 보낸 패킷이 오류가 생겼을 때 재전송을 하는 HOLB문제를 개선하기 위해 도입되었습니다.

##### 슬기's 답변: 제일 초기 버전은 0.9버전으로 간단한 HTML문서를 가져오는 데 사용되어 GET요청 만 지원하였습니다. 다음 버전은 1.0버전으로 첫 공식 버전으로 요청과 응답헤더가 도입되며 여러 HTTP 메서드가 지원되었습니다. 1.1 버전은 가장 널리 사용되는 버전 중 하나로 지속적 연결기능을 통해 한 연결에서 여러 요청을 처리할 수 있으며 2.0 버전은 성능 향상에 중점을 두었으며 3버전은 아직 적용 초기 단계이며 기존 TCP 대신 QUIC 프로토콜을 기반으로 합니다.

##### 정호's 답변: HTTP는 지금까지 총 4가지의 버전이 출시되었습니다. HTTP/1.0은 각 요청에 대해 새로운 연결로 맺어야 했기 때문에 성능이 좋지 않았습니다. 헤더 크기가 크고 같은 헤더를 반복해서 전송했어야 했습니다. 또한 요청 간에 상태 정보를 유지하지 않았습니다. HTTP/1.1은 지속 연결을 통해 여러 요청과 응답을 하나의 연결로 처리할 수 있게 되어 성능이 향상되었습니다. HTTP/2.0은 다중화를 통해 하나의 연결로 여러 요청과 응답을 동시에 처리할 수 있어 성능이 크게 향상되었습니다. 또한 헤더 압축 기능을 통해 헤더 정보를 압축하여 리소스를 절약하고 서버 푸시 기능을 통해 서버가 클라이언트의 요청 없이도 필요한 리소스를 미리 전송할 수 있도록 됐습니다. 그리고 마지막으로 HTTP/3.0은 UDP 기반으로한 QUIC 프로토콜을 사용해 더 빠른 통신이 가능하게 되었습니다. 또한 헤더 압축과 다중화를 개선하여 HTTP/2.0보다 더 효율적인 통신이 가능하게 되었습니다. 마지막으로 연결 설정 및 해제가 최적화되어 더 빠른 속도를 제공하게 되었습니다.

#### 🔗🔗 슬기's 꼬리의 꼬리의 꼬리질문: 지속적 연결 (keep-alive)에 대해 더 자세히 설명해주세요

##### 슬기's 답변: 지속적인 연결이란 HTTP/1.1에서 도입된 기능으로 한번의 TCP 연결을 통해 여러개 HTTP요청과 응답을 순차적으로 처리할 수 있게 해주는 메커니즘입니다. 동작 방식은 클라이언트에서 HTTP 요청을 보낼 때 Connection: keep-alive 헤더를 포함시키면 서버는 해당 연결을 일정 시간동안 열려 있게 유지해주는 방식입니다.

#### 🔗🔗 꼬리의 꼬리의 꼬리질문: HTTP 2.0과 HTTP 3.0의 주요 차이점은 무엇인가요?

##### 나라's 답변: 2.0에서 사용된 TCP기반의 프로토콜을 UDP기반으로 동작하는 QUIC라는 프로토콜로 바뀌었으며 TCP과정과 TLS과정을 적용하여 높은 성능과 기능을 제공합니다.

##### 슬기's 답변: 2.0 의 경우 TCP를 기반으로 하고 3.0의 경우 QUIC(Quick UDP Internet Connections)라는 새로운 프로토콜을 기반으로 합니다. 3.0 버전은 2.0버전의 연결 설정을 최적화하여 연결 시간을 크게 단축 시키며 2.0의 경우 암호화가 선택적이라 하면 3.0의 경우 QUIC에 암호화 기능이 내장되어 기본적으로 모든 연결이 암호화되어 성능과 보안에 좀 더 향상시키기 위해 설계되었습니다.

##### 정호's 답변: HTTP/2.0은 TCP 기반의 전송 프로토콜을 사용하며, 다중화와 헤더 압축 등을 통해 성능을 향상시켰습니다. 하지만 TCP를 기반으로 하기 때문에 연결 설정 및 해제 과정이 필요했습니다. HTTP/3.0은 UDP를 기반으로 하는 QUIC라 불리는 프로토콜을 사용합니다. HTTP/2.0에서 생긴 다중화와 헤더 압축을 더 발전시켜 성능을 향상 시켰고, HTTP/2.0과 달리 연결 설정 및 해제를 최적화하여 연결을 효율적으로 관리할 수 있게 되었습니다. 또한 오류 복구를 빠르게 처리할 수 있도록 설계하여 더 안정적입니다.

## 🔗 꼬리질문: 웹 서버와 WAS의 차이점

### 나라's 답변: 둘 다 클라이언트 요청을 처리하는 역할이지만 웹 서버는 클라이언트에서 HTTP요청을 받아 정적인 컨텐츠(HTML, CSS, JS)을 반환하지만 WAS(Web Application Server)는 동적인 컨텐츠(DB조회, 비즈니스 로직 처리)를 처리하기 위해서 설계되어졌으며 요청에 의해서 데이터를 생성하여 응답하는 것이 차이점입니다.

### 슬기's 답변: 웹 서버와 WAS(Web Application Server)는 모두 웹 기반 서버 이지만, 웹 서버의 경우 정적인 컨텐츠를 처리하며 주로 Apache, Nginx가 예로 있습니다. 반대로 WAS의 경우 동적인 컨텐츠를 처리하기 위해 설계되어 요청이 들어오면 동적으로 페이지를 생성하여 응답하는 방식으로 주로 Tomcat 이 예로 들 수 있습니다.

### 정호's 답변: 웹 서버는 HTML 문서, 이미지, CSS 파일과 같은 정적인 콘텐츠를 제공하는 데 주로 사용됩니다. 주로 정적인 파일을 제공하므로 처리 속도가 빠르고, 가벼운 성격을 가지고 있으며 대표적으로 Apache, NginX가 있습니다. WAS는 다양한 프로그래밍 언어로 작성된 웹 애플리케이션의 실행을 담당합니다. 동적인 콘텐츠를 제공하며, Java EE, Python, Tomcat 등이 WAS입니다.

## 🔗 꼬리질문: url 이란?

### 나라's 답변: Uniform Resource Locator로써 인터넷에서의 리소스의 위치를 나타내는 주소입니다. 이와 같이 주소를 주소창에 입력한다면 해당 리소스에 접근이 가능하며 구성요소는 프로토콜(https:~~), 호스트(www.~~~.com), 포트(:8080), 경로(/path/bla), 쿼리스트링(?key=blabla) 등으로 나뉠 수 있습니다.

### 슬기's 답변: URL(Uniform Resource Locator)은 인터넷에서 자원의 위치를 나타내는 고유한 주소로 프로토콜, 도메인 이름, 포트번호, 경로, 쿼리문자열로 구성되어있습니다.

### 정호's 답변: URL은 "Uniform Resource Locator"의 약자로, 인터넷 상에서 리소스(자원)의 위치를 가리키는 주소입니다. 즉, 웹페이지, 이미지, 동영상 등의 다양한 리소스가 어디에 위치해 있는지를 나타내는 것입니다.

#### 🔗🔗 꼬리의 꼬리질문: url vs uri 차이

##### 나라's 답변: Uniform Resorce Identifier로 '통합 자원 식별자'라고 해석할 수 있습니다. 리소스를 고유한 식별을 하는 역할로 URL은 리소스의 "위치"를 나타내는 것입니다. 즉 URI안에 URL이 포함되어 있는 것입니다. URL과 URI 비교한다면 URI는 지도,URL은 집주소와 비교할 수 있습니다.

##### 슬기's 답변: 종종 혼용되어 사용되지만 URI의 I는 Identifier로 인터넷 자원("무엇")을 식별하는 것이고 URL은 자원의 위치를 가리키는 ("어디에")를 의미합니다. 즉, 모든 URL은 URI이지만, 모든 URI가 URL은 아닙니다.

##### 정호's 답변: URI는 URL의 상위 개념입니다. URL은 URI의 하위 집합으로, URL은 URI의 한 형태로 볼 수 있습니다. URI는 식별자와 로케이터로 나뉘며, URL은 주로 로케이터의 역할을 합니다.

## 🔗 꼬리질문: 브라우저에서 CORS의 기본동작에 대해서 설명해주세요

### 나라's 답변: CORS는 출처를 비교하여 다른 출처라도 리소스에 접근을 제어하는 정책입니다. 우선 클라이언트에서 HTTP요청의 헤더에 Origin을 담아서 서버에 보내고 서버는 응답헤더에 Access-Control-Allow-Origin을 담아 클라이언트에 전달합니다. 이후 클라이언트에서는 Origin과 서버의 ACAO를 비교하여 유효하지 않는다면 차단하거나 아님 사용할지를 결정합니다.

### 슬기's 답변: 웹 페이지가 다른 출처의 리소스에 엑세스할 때 발생하는 제한사항 다룹니다, Same Origin Policy 이기 때문에 CORS가 필요합니다. 기본 동작은 사전에 요청을 하고 서버가 응답을 하며 Access-Control-Allow-Origin 헤더의 값을 비교하여 허용을 확인하며 실제 요청을 전송하여 서버 응답을 처리합니다.

### 정호's 답변: CORS는 'Cross-Origin Resource Sharing'의 약자로 웹 브라우저에서 실행되는 스크립트가 다른 도메인의 리소스에 접근할 수 있도록 권한을 부여하는 보안 기능입니다. 브라우저는 보안상의 이유로 스크립트가 하나의 Origin에서 로드한 문서나 스크립트가 다른 Origin 리소스에 직접 접근하는 것을 제한합니다. 여기서 동일한 Origin이란 프로토콜, 호스트, 포트가 동일한 것을 말합니다.

#### 🔗🔗 꼬리의 꼬리질문: 경험한 CORS에러에 대해서 설명해주세요, 없다면 예시를 들어주세요. (+ 해결방법)

##### 나라's 답변: 프로젝트 중 api서버에 HTTP요청을 보낼 때 CORS에러를 발견했습니다. 이때 백엔드 팀원과 커뮤니케이션을 통해 서버 측에서 CORS 헤더를 추가하여 도메인 요청을 허용하여 해결한 경험이 있습니다.

##### 슬기's 답변: API를 호출하는 백엔드 서버를 개발 중이었습니다. 리액트 서버는 localhost:3000에서 실행되었고, 백엔드 서버는 localhost:5000에서 실행되었습니다. 백엔드 서버에 CORS헤더 를 추가하여 해결할 수 있었습니다.

##### 정호's 답변: 사이드 프로젝트를 진행 중 서로 다른 Origin에서 API 요청을 보낼 때 CORS 에러가 발생한 적이 있습니다. 클라이언트에서 API 요청을 보낼 때 header 값에 Access-Control-Allow-Origin의 값을 모든 출처 허용으로 하고 서버측에서 CORS 허용 범위를 클라이언트의 Origin으로 변경 하여 해결한 경험이 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: 왜 SOP가 필요할까요?

##### 나라's 답변: Same Origin Policy(동일 출처 정책)는 같은 출처일때만 서버로 부터 데이터 요청을 받게 하는 정책입니다. 이는 악의적인 의도로 사이트가 사용자의 정보를 탈취하는 것을 막을 수 있으며 XSS나 CSRF와 같은 해킹을 방지할 수 있습니다.

##### 슬기's 답변: 웹 보안의 핵심 원칙 중 하나로, 사용자의 민감한 데이터를보호할 수 있으며 CSRF, XSS등 공격에 예방할 수 있으며 데이터의 무결성을 유지할 수 있기 때문에 필요합니다.

##### 정호's 답변: SOP는 웹 보안을 강화하기 위해 도욉된 중요한 보안 메커니즘입니다. SOP는 웹 페이지에서 실행되는 스크립트가 다른 출처의 리소스에 자유롭게 접근하는 것을 방지함으로써 보안을 강화합니다. 만약 SOP가 없다면 해커가 악의적인 스크립트를 다른 웹 사이트에 주입하여 사용자 정보를 탈취할 수 있습니다. 또한 SOP는 웹 애플리케이션을 출처별로 격리시켜, 한 출처에서 발생한 문제가 다른 출처에 영향을 미치지 않도록 합니다.

## 🔗 꼬리질문: OSI 7 layer와 각 계층에 대해 아는대로 설명해주세요.

### 나라's 답변: 네트워크 프로토콜이 통신하는 구조를 7계층으로 분리해 계층간에 작동하는 방식을 단계별로 파악할 수 있게 정한 것 입니다. 7계층은 물리,데이터 링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 나뉩니다. 1계층(물리)는 케이블이나 허브 등 전기적 신호로 변환해서 주고받는 것들을 의미합니다. 2계층(데이터링크)는 정보 전달을 수행하는 것으로 스위치 등의 기계가 있으며 맥주소를 가지고 물리계층에서 받은 정보를 전달합니다. 3계층(네트워크)는 데이터를 목적지까지 빠르게 전달하는 기능으로 라우팅이라고 부릅니다. 이때 IP할당, route 등이 이뤄집니다. 4계층(전송)은 포트를 열어서 프로그램들이 전송할 수 있게 합니다. 보통 TCP프로토콜을 사용합니다. 5계층(세션)은 논리적인 연결을 하며 통신하기위한 대문이라고 보면 됩니다. TCP/IP를 만들거나 없애는 것을 담당하고 책임집니다. 6계층(표현)은 데이터 표현을 암호화하는 과정이 해당되며 파일의 확장자를 구분하는 것도 이뤄집니다. 마지막 7계층(응용)은 HTTP, SMTP등의 프로토콜들이 있으며 최종 목적지입니다.

### 슬기's 답변: 네트워크 프로토콜을 추상적으로 7개 계층으로 나눈것을 의미합니다. lan선과 같은 바이트 전송하는 물리계층 그다음은 데이터 링크 전송 계층(라우팅), 네트워크 계층(IP), 전송계층(포트), 세션계층(TCP 연결/유지/해지), 표현계층(데이터 표현하는 방식 암호화 복호화), 응용계층(HTTP, FTP와 같은 프로토콜 정리)으로 구성되어있습니다.

### 정호's 답변: OSI 7 layer는 네트워크 프로토콜을 일곱 개의 추상적인 계층으로 나눈 것입니다. 계층 별로 설명드리자면 첫 번째로 물리 계층은 전기적, 기계적 특성을 다룹니다. 비트를 전송하기 위한 물리적 매체와 관련된 것으로 케이블, 허브, 리피터 등이 속합니다. 두 번째로 데이터 링크 계층은 프레임 단위로 데이터를 전송합니다. 물리 계층에서 발생할 수 있는 오류를 감지하고 수정합니다. MAC 주소를 이용하여 데이터를 송수신합니다. 세 번쨰로 네트워크 계층은 경로를 선택하고 패킷을 다른 네트워크로 전송합니다. 라우팅과 논리적인 주소 할당을 담당하며 IP 주소를 사용하여 목적지를 식별합니다. 네 번째로 전송 계층은 데이터의 신뢰성과 흐름 제어를 담당합니다. 에러 복구 및 재전송을 수행하며, 연결 설정과 해제를 관리합니다. 주로 TCP와 UDP 프로토콜을 사용합니다. 다섯 번째로 세션 계층은 데이터 교환의 동기화와 관리를 담당하며 다중 통신 세션을 구성하고 유지합니다. 여섯 번째로 표현 계층은 데이터의 형식을 변환하고 암호화/복호화하여 데이터를 응용 계층이 이해할 수 있는 형태로 변환합니다. 일곱 번째로 응용 계층은 최종 사용자에게 서비스를 제공하며, 프로토콜을 이해하고 사용자 인터페이스와 네트워크 서비스 간의 통신을 담당합니다.

물리 계층 => 데이터 링크 계층 => 네트워크 계층 => 전송 계층 => 세션 계층 => 표현 계층 => 응용 계층

UDP는 재전송과 연결 설정 및 해제가 없고 흐름 제어도 없다며 근데 어떻게 전송 계층에서 UDP를 사용하는거야?

#### 🔗🔗 꼬리의 꼬리질문: TCP/IP란 무엇인가?

##### 나라's 답변: TCP/IP는 네트워크 사이에서 정보를 주고받는 데에서 사용되는 통신 프로토콜의 모음이며 전송 제어 프로토콜(TCP)와 인터넷 프로토콜(IP)이 있습니다. TCP는 다른 기기로 데이터를 전송하는 것을 담당하며 IP는 데이터의 조각을 IP주소로 보내는 역할입니다. 합쳐서 부르는 이유는 같은 결과, 목표를 하기 때문에 하나로 불려지고 있습니다. TCP/IP는 총 4단계로 이뤄지고 응용, 전송, 인터넷, 데이터 링크 계층으로 이뤄져있습니다. 각각 사용자가 네트워크에 접근, 전송, IP로 데이터 패킷 전송, 연결이 되었는지 확인 합니다.

##### 슬기's 답변: 인터넷 통신에서 사용되는 프로토콜 스택입니다. IP 란 인터넷 프로토콜로 데이터를 패킷단위로 분할하여 송수신하며 TCP란 IP기반하에 동작하는 프로토콜로, 패킷의 순서보장, 중복제거 와같은 기능을 제공합니다.

##### 정호's 답변: TCP/IP는 네트워크 통신을 위한 기본 프로토콜 스택입니다. 여기서 TCP는 Transmission Control Protocol을 말하고, IP는 Internet Protocol을 말합니다. TCP는 데이터를 안정적으로 그리고 순서대로 전송하기 위한 프토콜이며, 데이터를 작은 패킷으로 나누어 보내고, 수신 측에서는 이를 다시 조립합니다. IP는 주로 컴퓨터 네트워크에서 데이터를 전송하는 데 사용됩니다. IP주소를 가지고 있어서, 데이터가 어디로 가야 하는 지를 식별하는 데 사용됩니다.

#### 🔗🔗 꼬리의 꼬리질문: TCP와 UDP의 차이점에 대해서 설명해보세요.

##### 나라's 답변: 둘다 전송 계층에서 사용되는 프로토콜(규약)입니다. 즉 데이터를 전달하고 전달하는 데이터의 오류를 검사하거나 재전송을 합니다. 이 둘의 차이점은 클라이언트와 서버가 연결된 상태에서 데이터를 주고받냐(TCP) 아님 연결되지 않는 상태에서 데이터를 주고받냐(UDP)의 차이점이 있습니다. 이런 연결, 비연결성에서 시작해서 전송 순서가 보장되냐, 신뢰성이 높냐, 속도가 느리냐 등이 세부적인 차이점이 있습니다.

##### 슬기's 답변: 모두 IP프로토콜 위에서 데이터 전송을 담당하는 프로토콜이지만, 연결방식, 신뢰성, 속도면의 차이점이있습니다. 먼저 TCP는 연결 지향적이기에 신뢰성 있는 데이터전송을 보장하며 그렇기에 UDP보다는 상대적으로 느릴 수 있습니다. 반면 UDP는 연결 비지향적이기에 신뢰성을 보장하지않아 패킷의 손실이나 데이터 순서 변경이 일어날 수 있습니다. 그렇지만 빠른 전송 속도를 가집니다.

##### 정호's 답변: TCP와 UDP 둘 다 인터넷 프로토콜 스위트의 일부로, 데이터를 전송하기 위한 프로토콜이지만, 몇 가지 차이점이 있습니다. TCP는 연결 지향 프로토콜이라 불립니다. 통신하기 전에 먼저 연결을 설정하고, 데이터를 전송한 후에는 연결을 정리합니다. 이로써 안정적이고 순서대로 데이터를 전송할 수 있습니다. 하지만 UDP의 경우에는 연결을 설정하거나 해제하지 않습니다. 데이터를 전송할 때 미리 연결을 설정하지 않고, 각각의 패킷은 독립적으로 처리됩니다. 그래서 TCP보다 빠르게 데이터를 보낼 수 있지만, 순서가 보장되지 않고, 에러 발생 시 재전송이 이루어지지 않습니다. 또한 TCP는 흐름 제어와 혼잡 제어 메커니즘이 내장되어 있어. 네트워크 상황에 따라 전송 속도를 조절하여 혼잡을 방지하고, 수신자의 처리 속도에 맞추어 데이터를 보낼 수 있습니다. UDP의 경우 흐름 제어나 혼잡 제어가 없기 때문에 데이터를 그냥 보내고 받기만 할 뿐입니다. 앞서 말했듯이 TCP는 데이터를 전송할 때 에러 체크와 재전송 메커니즘이 있어서, 데이터 손실이나 손상을 방지할 수 있고, 순서가 보장되기 때문에 데이터가 도착한 순서대로 재조립될 수 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: 패킷이란 무엇인가?

##### 나라's 답변: 데이터를 주고 받을 때 전송되는 데이터 조각, 단위라고 말할 수 있습니다. 전송쪽에서 데이터를 패킷으로 분할하여 전송되며 수신하는 쪽에서는 분할된 패킷을 복원하여 데이터를 수신합니다. 이렇게 쪼개서 보내는 이유는 데이터를 한번에 보낸다면 대역폭을 많이 차지하는 상황을 방지하기 위해 패킷으로 데이터를 주고받습니다.

##### 슬기's 답변: 패킷이란 데이터를 작은 단위로 나눈것을 의미합니다.

##### 정호's 답변: 패킷은 데이터 통신에서 정보를 전송하는 작은 단위를 말합니다. 큰 데이터를 보낼 때, 큰 데이터를 여러 작은 조각으로 나누어서 보내는데, 각각의 작은 조각이 패킷입니다. 이렇게 나누어진 패킷은 목적지에 도착해서 원래의 데이터로 재조립됩니다.

#### 🔗🔗 꼬리의 꼬리질문: TCP의 신뢰성을 보장하는 방법을 설명해보세요.

##### 나라's 답변: TCP는 신뢰성을 보장하기 위해 여러 방법을 사용합니다. 데이터를 전달할 때 패킷에 순서를 할당하여 수신측에서 패킷의 손상여부가 있을 때 재전송을 하여 패킷을 다시 받도록 하며 흐름제어와 혼잡제어 매커니즘을 통해 를 통해 처리할 수 있을 정도로만 데이터를 보내는 속도를 조절하여 혼잡성을 낮춰 성능을 유지하게 해줍니다. 마지막으로 TCP연결과 연결을 끊을 때 핸드쉐이크 과정을 거치며 신뢰성을 높힙니다.

##### 슬기's 답변: 연결 지향적 접근으로 통신 을 시작하기 전 송신자와 수신자간 연결을 설정하고 양쪽 모두 데이터 전송준비가 되었는지 확인할 수 있으며 순서를 보장하고 오류를 검출하고 재전송하는 과정과 같은 과정을 거치며 신뢰성을 보장할 수 있습니다.

##### 정호's 답변: TCP는 신뢰성을 보장하기 위해 여러 메커니즘을 사용합니다. 첫 번째는 에러 감지와 복구입니다. TCP는 각각의 패킷에 순서 번호를 할당하고, 수신 측에서는 이를 통해 패킷의 손상 여부를 감지하고, 손상된 패킷이 감지되면 재전송을 요청하여 신뢰성을 유지합니다. 두 번째는 흐름 제어입니다. TCP는 수신 측에서 송신 측으로 흐름 제어 정보를 보내어 송신 측이 데이터를 너무 빨리 보내지 않도록 제어합니다. 수신 측이 처리할 수 있는 양만큼의 데이터만을 송신 측에 알려주어, 과다한 데이터의 누적을 방지합니다. 세 번째는 혼잡 제어입니다. TCP는 네트워크 혼잡을 방지하기 위해 혼잡 윈도우와 같은 메커니즘을 사용합니다. 네트워크 혼잡이 감지되면 전송 속도를 조절하여 혼잡을 완화하고 네트워크 성능을 유지함으로써 신뢰성을 향상시킵니다. 마지막으로 3-way 핸드셰이크입니다. TCP는 연결을 설정하기 위해 클라이언트와 서버 간에 3-way 핸드셰이크를 수행함으로써, 양쪽 간의 신뢰성 있는 통신을 확립합니다.

#### 🔗🔗 꼬리의 꼬리질문: 3 way-handshake와 4 way-handshake를 설명해주세요.

##### 나라's 답변: 3 way-handshake는 TCP가 연결을 하는 과정인데요. 클라이언트와 서버간 서로의 상태를 확인하는 과정이라고 설명할 수 있습니다. 먼저 클라이언트에서 SYN이라는 값을 서버에 보내어 데이터을 받을 준비가 되었냐라고 보냅니다(이때 클라이언트는 SYN_SENT상태로 ACK이 날라오기를 기다리는 상태로 대기합니다.). 이후 서버가 받을 준비가 되었다면 ACK을 클라이언트에 날려 잘받았다라고 클라이언트에게 알려줍니다. (SYN값에 1을 더합니다.) 이후 SYN+ACK 값을 받은 클라이언트는 다시 ACK을 서버에게 날려 응답을 해줍니다. 4way-handshake는 연결을 해제하는 과정입니다. 클라이언트가 서버에게 연결을 끊는 FIN을 보내고 FIN-WAIT-1상태로 들어갑니다. 이후 서버는 ACK을 보내서 애플리케이션의 close를 요청합니다. 이때 클라이언트는 FIN-WAIT-2로 대기상태가 변경됩니다. 이후 close요청을 받은 서버가 종료 프로세스를 진행하고 FIN을 클라이언트에게 보냅니다. 이때 서버는 LAST_ACK로 상태를 바꿉니다. FIN을 받은 클라이언트는 ACK을 서버에게 전송하고 상태를 TIME-WAIT로 바꿉니다.

##### 슬기's 답변: 일반적으로 3way는 연결할 때 사용, 4way는 해제할 때 사용되는 방식을 의미합니다. 연결 방식의 과정에서 3가지 응답 요청 값에 대한 것을 3way 이고 4가지는 fin 값이 추가된것으로 알고있습니다.

##### 정호's 답변: 3 way-handshake는 TCP 연결을 설정하기 위한 과정으로 클라이언트와 서버 간에 세 개의 메시지를 교환하는 것을 의미합니다. 첫 번째는 Client가 Server에게 연결을 맺고 싶다는 요청을 보내는 과정이며, 이를 위해 SYN 메시지를 보냅니다. 두 번째로 Server는 Client의 요청을 받았다는 응답과 함께, 자신도 Client와 연결을 맺을 준비가 되었다는 것을 알리기 위해 SYN-ACK 메시지를 보냅니다. 세 번째로 Client는 Server의 응답을 받고, 연결 요청에 대한 확인을 서버에게 보내기 위해 ACK 메시지를 보냅니다. 이러한 과정을 통해 Client와 Server 간에 안정적인 연결이 설정됩니다. 4 way-handshake는 연결을 종료하기 위한 과정을 말합니다. 첫 번쨰로 Client가 Server에게 연결을 종료하고 싶다는 의미의 FIN 메시지를 보내고, 두 번째로 Server는 Client의 종료 요청을 받고, 연결을 종료할 준비가 되었다는 ACK 메시지를 보냅니다. 세 번째로 Server는 자신도 연결을 종료하고 싶다는 의미의 FIN 메시지를 클라이언트에게 보냅니다. 네 번째로 Client는 Server의 종료 요청에 대한 확인을 보내고, 연결을 종료함을 알리기 위해 ACK 메시지를 보냅니다. 이렇게 네 단계를 거쳐 Client와 Server 간의 연결이 안전하게 종료됩니다.

## 🔗 꼬리질문: REST API란?

### 나라's 답변: REST아키텍처의 조건을 따르는 API를 말합니다. REST아키텍처의 원칙은 1. 자원을 중심으로 설계되어야하며 URI로 식별이 되어야합니다. 2. 상태가 없어야하며 서버가 클라이언트의 상태를 기억하면 안됩니다. 3. 응답이 캐시가 가능해야합니다. 4. 클라이언트-서버의 구조로 설계되어야합니다. 5. 클라이언트가 중간 서버를 거칠 수 있어야하며, 계층은 독립적으로 구성될 수 있어야합니다. 6. 서버는 필요에 따라서 코드를 클라이언트에 전송이 가능해야하며 이로써 기능이 확장될 수 있어야합니다. REST API는 주로 HTTP메서드를 사용하며 GET, POST, PUT, DELETE등이 있습니다.

### 슬기's 답변: REST 원칙을 기반으로 한 웹 서비스 API를 의미합니다. 일반적으로 HTTP를 사용하여 웹 클라이언트와 상호작용하며 url을 사용하여 웹 서비스의 자원을 식별하고 http메서드로 crud를 수행합니다.

### 정호's 답변: REST API는 Representational State Transfer의 약자로, 웹 기반 시스템 간에 통신을 위한 아키텍처 스타일입니다. 이는 네트워크를 통해 자원(데이터 또는 서비스)을 표현하고, 해당 자원에 대한 상태를 주고받기 위한 규칙들을 정의합니다. REST API는 HTTP 프로토콜을 기반으로 하며, 자원은 URI로 식별되고, HTTP 메서드를 사용하여 자원에 대한 행위를 나타낼 수 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: API란 무엇일까요?

##### 나라's 답변: Application Programming Interface로 쉽게말해 프로그램들이 상호작용하는 것을 도와주는 매개체라고 말할 수 있습니다. 클라이언트를 식당 손님, 요리사를 서버라고 가정했을 때 API는 점원이라고 예를 들수 있습니다.

##### 슬기's 답변: API는 일반적으로 데이터를 검색, 생성, 수정, 삭제하는 데 사용되는 함수와 메서드를 제공합니다.

##### 정호's 답변: API는 Application Programming Interface의 약자로, 소프트웨어 애플리케이션 간에 상호 작용하기 위한 인터페이스를 말합니다. 간단히 말하면 어떤 프로그램이 다른 프로그램과 소통하기 위한 규약이라고 생각하면 됩니다. 웹 개발에서 API는 보통 웹 서비스와 통신을 위한 인터페이스를 가르킵니다. 이를 통해 다른 서비스의 기능을 사용하거나 데이터를 가져올 수 있습니다.

#### 🔗🔗 꼬리의 꼬리질문: RESTFul이란 무엇인가요

##### 나라's 답변: REST아키텍처 원칙(자원식별가능, 무상태성, 캐시가능, 클라이언트-서버구조,다중계층, 옵셔널)을 잘 지킨 것을 RESTful하다 라고 말할 수 있습니다.

##### 슬기's 답변: REST원칙을 충분히 따르는 API를 의미합니다.즉 URI패턴으로 자원을 식별할 수 있고, HTTP메서드로 상태를 변경할 수 있으며 각 요청이 독립적여야하는 무 상태성의 원칙을 따르는것을 의미합니다

##### 정호's 답변: RESTFul은 REST(Representational State Transfer) 아키텍처 스타일을 따르는 웹 서비스를 말합니다. RESTFul 웹 서비스는 몇 가지 주요 원칙을 따르며, 이를 통해 효율적이고 확장 가능한 웹 애플리케이션을 구축할 수 있습니다. 주요 원칙은 Resource, Representation, Stateless, Uniform Interface, Layered System 등이 있습니다.

## 🔗 꼬리질문: 프록시란 무엇일까요?

### 나라's 답변: 빠른 연결과 안전한 통신을 위해서 중간에서 대신 통신하는 것을 프록시라고 말하며 보통 클라이언트, 웹서버 중간에 위치해있습니다. 프록시를 통해 보안적인 목적, 캐시된 정보를 서버에 재연결을 하지 않게 하는 목적 등이 있습니다.

### 슬기's 답변: 프록시란 클라이언트와 서버 사이에 중개자 역할을 하는 서버입니다. 주로 캐싱, 필터링, 보안, 데이터 압축과 같은 역할을 하여 웹 트래픽의 효율성과 보안을 향상시킬 수 있습니다.

### 정호's 답변: 프록시는 두 시스템 간에 중개자로서 동작하는 컴퓨터나 응용 프로그램을 가리킵니다. 주로 네트워크 트래픽을 관리하거나 보안을 강화하기 위해 사용됩니다. 프록시의 종류는 다양합니다. 기본적인 4가지 프록시를 설명 드리자면, 네트워크 프록시는 Client와 Server 간의 통신에서 중계자 역할을 하는 서버를 말합니다. Client는 프록시 Server에 요청을 보내고, 프록시 Server는 이 요청을 대신하여 목적지 Server에 전달합니다. 이를 통해 네트워크 트래픽을 제어하거나 필터링할 수 있습니다. 웹 프록시는 웹 브라우저와 웹 서버 간의 통신에서 중개자 역할을 하는 것을 말합니다. 웹 페이지의 캐싱, 애드블락, 사용자 인증, 로깅 등 다양한 기능을 수행할 수 있습니다. 보안 프록시는 보안을 강화하기 위해 사용되는 프록시로, 외부와의 통신을 검사하고 악성 트래픽이나 해킹 시도를 차단하는 역할을 합니다. 마지막으로 리버스 프록시는 Client를 대신하여 Server로 요청을 전달하는 Server측의 프록시입니다. 주로 로드 밸런싱, SSL 암호화, 캐싱과 같은 서버측 기능을 제공합니다.

그럼 Next.js의 Router Handler는 프록시인가요?

#### 🔗🔗 꼬리의 꼬리질문: 프록시는 어떨 때 사용하면 좋을까?

##### 나라's 답변: 프록시는 보안적인 부분에서 이점이 있기 때문에 개인정보를 보호해야할 때와 캐싱을 통한 네트워킹 속도를 높히고 싶을 때 사용하면 높은 효율성을 보일 것이라고 생각합니다.

##### 슬기's 답변: 주로 캐싱을 필요로 하는 경우 혹은 클라이언트의 실제 IP주소 혹은 서버의 IP주소를 를 숨겨야 할 경우 사용됩니다.

##### 정호's 답변: 프록시는 보안 강화, 콘텐츠 필터링, 로드 밸런싱, 캐싱, 익명성 보장, 트래픽 모니터링 등 다양한 상황에서 사용될 수 있습니다.

#### 🔗🔗🔗 꼬리의 꼬리꼬리질문: XSS나 CSRF에 대해서 간단히 설명해주세요.

XSS(Cross-Site Scripting)으로 악의적으로 스크립트가 사용자의 브라우저에 실행하게 하는 것으로 세션이나 쿠키를 탈취하는 해킹방식입니다.

CSRF는 사용자가 로그인 상태일 때 해킹범이 사용자 대신에 사이트에 비정상적인 요청을 하도록 합니다. 이렇게 되면 사용자에게는 이상한 링크, 이미지 등을 보여지게하고 링크나 이미지를 클릭했을 때 정보를 탈취하는 방식입니다.

## 📝 REFERENCE

### 나라

[https://developer.mozilla.org/ko/docs/Web/HTTP/Overview](HTTP)
[https://velog.io/@dyunge_100/WEB-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95](통신과정)
[https://dkrnfls.tistory.com/289](HTTP)
[https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-20-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90#http*2.0*%EA%B0%9C%EC%84%A0%EC%A0%90](HTTP2.0)
[https://www.elancer.co.kr/blog/view?seq=74](URL,URI)
[https://nordvpn.com/ko/blog/tcp-ip-protocol/](TCP/IP)
[https://dev-coco.tistory.com/144](TCP/IP)
[https://shlee0882.tistory.com/110](OSI7계층)
[https://devmoony.tistory.com/183](패킷)
[https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html](REST-API)
[https://velog.io/@osk3856/TLS-Handshake](TLSHandShake)

### 슬기

[https://velog.io/@gyumin_2/브라우저-동작-원리-주소창에-URL-입력-시-일어나는-과정-백엔드-편](https://velog.io/@gyumin_2/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-URL-%EC%9E%85%EB%A0%A5-%EC%8B%9C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%BC%EC%A0%95-%EB%B0%B1%EC%97%94%EB%93%9C-%ED%8E%B8)

[https://velog.io/@apolontes/21.02.23-TIL52-면접스터디-3주차-2](https://velog.io/@apolontes/21.02.23-TIL52-%EB%A9%B4%EC%A0%91%EC%8A%A4%ED%84%B0%EB%94%94-3%EC%A3%BC%EC%B0%A8-2)

[https://dev-coco.tistory.com/161](https://dev-coco.tistory.com/161)

### 정호

https://velog.io/@bky373/Web-%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%99%80-WAS
https://velog.io/@bky373/Web-HTTP%EC%99%80-HTTPS-%EC%B4%88%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC
https://codechasseur.tistory.com/25
https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-CORS-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%F0%9F%91%8F

---
