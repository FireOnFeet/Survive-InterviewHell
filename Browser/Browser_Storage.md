# 📆 날짜: 2023-10-17

# 주제 : 쿠키, 세션, Storage, 토큰 & OAuth, JWT, 인증

## 🎯 공통 질문: 쿠키의 정의 및 특징에 대해 설명해주세요.

### 나라's 답변: 사용자가 웹 사이트를 방문했을 때 서버를 통해 사용자의 컴퓨터에 설치되는 기록정보파일입니다. 쿠키는 HTTP의 비연결성, 무상태 특성을 해결하기 위해 사용자의 정보를 기억할 수 있는 수단이며 브라우저를 종료하여도 참조가 가능하며 최대 300개의 쿠키를 저장 가능합니다. set-cookie속성을 사용한다면 클라이언트에 쿠키 생성이 가능합니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 쿠키를 왜 사용하나요?

### 나라's 답변: HTTP통신에서 한번 연결을 맺고 끊고, 서버는 클라이언트 상태를 모르는 특징이 있습니다. 이러한 특징은 매번 새로운 인증단계를 거쳐야 하는 번거로움 때문에 클라이언트에 쿠키를 사용하여 서버가 클라이언트를 식별할 수 있도록 하기 위해서 사용합니다.

키워드 : HTTP통신의 특성, 서버와 클라이언트 식별

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 쿠키는 어떻게 동작하나요?

### 나라's 답변: 클라이언트가 정보를 요청하면 서버는 쿠키를 생성합니다, 이후 HTTP헤더에 응답을 보내고 클라이언트는 로컬에 있는 쿠키 저장소에 쿠키를 저장합니다. 다시 클라이언트가 정보를 요청할 때 HTTP헤더에 쿠키를 담아서 보내는데 수정된 정보가 있다면 서버는 수정된 정보를 활용하고 난 뒤 다시 쿠키를 담아 클라이언트에 응답을 보냅니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 지속 쿠키와 세션 쿠키의 차이점은?

### 나라's 답변: 만료 시점을 지정하는 것에 차이가 있습니다. 만료 시점을 지정한다면 지속 쿠키이며 만료 시점까지 쿠키가 남아 있으며, 만료 시점을 지정하지 않는다면 세션 쿠키고 세션이 종료될 때 (브라우저 종료) 삭제됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 쿠키의 보안 취약점은 무엇이 있나요? 그리고 이를 어떻게 해결할 수 있을까요?

### 나라's 답변: 쿠키는 브라우저에 즉, 사용자의 로컬에 저장되기 때문에 이는 조작되거나 가로챌 가능성이 있습니다. 이런 취약점은 세션 방식을 도입해서 해결 할 수 있으며 만료시간을 짧게 설정하여 새로운 토큰 값을 부여하는 방식으로 해결 할 수 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 쿠키와 써드파티 쿠키(Third-Party Cookies)의 차이점은 무엇인가요?

### 나라's 답변: 쿠키의 종류에는 퍼스트파티, 서드파티 쿠키가 있으며 서드파티 쿠키는 사용자가 방문한 도메인이 아닌 다른 도메인에서 발행한 쿠키 파일을 말합니다. 써드파티 쿠키는 사용자가 방문한 사이트에서 부터 설정된다는 차이점이 있으며 써드파티 쿠키는 사용자의 행동을 추적하여 데이터 수집하는 목적이며 쿠키는 사용자의 정보를 저장하는 데에 목적이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🎯 공통 질문: 세션의 정의 및 특징에 대해 설명해주세요.

### 나라's 답변: 세션은 클라이언트와 서버간의 연결 상태를 의미하며 연결 상태는 접속이 종료되기 전의 상태를 말합니다. 세션은 정보를 로컬에 저장하는 것이 아닌 서버에 저장하며 서버에서 세션ID를 발급하는데 이는 서버와의 접속이 끊길 때 세션ID가 제거됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 세션의 동작 방식은?

### 나라's 답변: 클라이언트가 사이트에 접속해 서버에 요청하고 서버는 클라이언트에 세션ID만들어서 응답해줍니다. 이후 클라이언트는 받은 세션ID를 HTTP헤더에 쿠키에 넣어 데이터 요청을 하고 서버는 받은 세션ID를 기준으로 클라이언트를 구별하여 데이터를 보냅니다. 이후 클라이언트가 접속을 종료된다면 서버는 세션ID를 제거시킵니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 세션의 생명주기는 어떻게 관리되나요?

### 나라's 답변: 세션은 사이트에 접속하면 세션이 생성되며 서버에서 고유한 세션ID를 만들어서 클라이언트에 저장합니다. 이후 세션에 만료시간을 설정한다면 시간이 만료되었을 때나 브라우저를 닫는다면 만료되거나 세션을 삭제됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 세션은 왜 사용하나요?

### 나라's 답변: 보안적인 측면에서 사용자의 인증 정보를 클라이언트 측이 아닌 서버측에서 관리하기에 좋습니다. 또한 HTTP통신을 하면서 사용자의 상태정보를 저장하고 유지하면서 사용할 수 있기 때문에 사용합니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 세션 하이재킹이란 무엇인가요? 그리고 그것을 방지하기 위한 방법은?

### 나라's 답변: 세션 하이재킹은 사용자의 세션을 해킹범이 가로채어 사용자인 척 하면서 사이트에 공격을 하는 것 입니다. 이런 공격을 방지하기 위해서는 HTTPS를 사용하여 암호화된 통신을 진행하거나 세션 유지시간을 정하여 일정 시간 이후 자동적으로 로그아웃하도록 하거나 JWT을 이용하여 보호를 할 수 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 세션 저장 위치에 따른 장단점은 무엇인가요?

### 나라's 답변: 세션을 클라이언트에 저장한다면 서버에 저장하지 않아 부하를 줄일 수 있고 데이터를 클라이언트측에서 가져올 수 있기에 빠르게 사용할 수 있습니다. 하지만 클라이언트에 저장되기 때문에 보안적인 면에서 취약할 수 있으며 데이터를 적재할 때 서버보다 적게 저장됩니다. 서버에 저장한다면 보안적 측면에서 좋을 수 있으며 클라이언트측에서 저장할 때 보다 많은 데이터를 처리할 수 있습니다. 하지만 그만큼 부하가 발생할 수 있으며 대규모 트래픽을 처리할 때 한계점이 존재할 수 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🎯 공통 질문: 브라우저 저장소에 대해 설명해주세요.

### 나라's 답변: 로컬, 웹 스토리지와 쿠키가 있습니다. 쿠키는 브라우저에 쿠키를 저장하여 서버가 클라이언트를 식별할 수 있도록 합니다. 웹 스토리지는 브라우저에 저장하며 쿠키보다 많은 데이터를 저장할 수 있습니다. 로컬과 세션 스토리지로 구분되며 로컬 스토리지는 데이터가 브라우저가 닫혀도 데이터가 삭제되지 않으며 세션 스토리지는 브라우저가 닫히면 데이터가 초기화됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 각 브라우저 저장소의 사용 예시를 들어주세요.

### 나라's 답변: 쿠키는 다시보지않습니다 라는 팝업창, 로컬스토리지는 자동로그인 기능, 세션스토리지는 임시 로그인 같은 예시가 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 브라우저 저장소에 데이터를 암호화하는 방법은 무엇인가요?

### 나라's 답변: HTTPS와 같은 보안 프로토콜을 사용하거나, SSL,TLS와 같이 데이터 암호화하여 전송합니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: indexedDB가 무엇인지 설명해주세요.

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 로컬 스토리지와 세션 스토리지의 차이점을 설명해주세요.

### 나라's 답변: 브라우저를 꺼도 로컬 스토리지에 데이터는 남아있습니다. 세션 스토리지는 브라우저를 종료하면 데이터가 초기화됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 로컬 스토리지를 사용할 때의 보안 취약점은 무엇인가요?

### 나라's 답변: 브라우저에 데이터를 저장하기에 XSS공격에 취약할 수 있습니다. 또한 로컬 스토리지는 만료기간이 없어 정보가 탈취될 가능성이 높다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 웹 스토리지(Web Storage)와 쿠키의 사용 케이스는 어떻게 다른가요?

### 나라's 답변: 웹 스토리지는 쿠키보다 많은 데이터를 저장할 수 있으며 데이터 전송부분에서 쿠키는 매 요청마다 서버에 전송되지만 웹 스토리지는 클라이언트에 저장됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🎯 공통 질문: 토큰이란 무엇인가요?

### 나라's 답변: 토큰은 데이터의 조각으로 인증과 권한을 관리할 때 사용됩니다. JWT, 액세스 토큰, 리프레쉬 토큰이 있으며 사용자의 상태를 인증하고 권한을 부여할 수 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 토큰의 인증 과정에 대해서 설명해주세요.

### 나라's 답변: 1. 클라이언트가 서버에 로그인 요청을 한다. 2. 서버는 정보가 일치하는 지 확인하고 클라이언트에 보낼 암호화된 토큰을 생성한다. 3. 토큰을 클라이언트에 보내면, 클라이언트는 토큰을 저장한다.(저장위치는 로컬, 쿠키 등 다양) 4. 클라이언트가 HTTP헤더에 토큰을 담아 보낸다. 5. 서버는 토큰을 해독하여 맞는지 판단 후 요청을 처리하고 응답을 보낸다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: Access Token, Refresh Token에 대해서 설명해주세요.

### 나라's 답변: Access token과 refresh token은 사용자를 증명하게 해주는 토큰입니다. access token은 일정 시간동안 신뢰있는 사용자라는 것을 증명해줍니다. Access token은 정보(데이터)에 접근할 때 사용되며 보안을 위해 일반적으로 짧은 기간을 가지게되며 토큰이 만료된다면 API에 접근할 수 없게 됩니다. Refresh Token은 Access token이 만료되었을 때 새로운 Access Token을 얻기위해 사용이 됩니다. Refresh token은 Access token보다 긴 기간을 가지며 반복되는 로그인 처리 없이 토큰을 갱신할 수 있게 합니다. Access Token은 클라이언트가 가지며 실제로 유저의 정보가 담긴 정보가 담겨있습니다. Refresh Token은 보통 DB에 유저정보와 같이 기록됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 토큰 기반 인증에서 토큰의 무효화는 어떻게 처리되나요?

### 나라's 답변: 토큰 만료시간을 설정하는 방법, 만료시간이 끝난다면 Refresh Token을 사용하여 Access Token을 주기적으로 갱신하는 방법이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: OAuth란 무엇인가요?

### 나라's 답변: 사용자들이 비밀번호를 제공하지 않고 자신의 정보에 대해서 사이트나 애플리케이션의 접근 권한을 부여하는 프로토콜입니다. 예를들어 facebook, google로 로그인하기가 있습니다. Resource Owner, server, client, Authorization Server로 구성되며 1.0, 2.0버전이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: OAuth의 동작 과정을 말해주세요.

### 나라's 답변: 사용자가 google로 로그인하기 요청 후 client에서 ID와 Redirect할 URI를 발급받음, URI에 로그인 요청후 로그인페이지를 받아 ID와 password를 입력하면 Authoriztion code를 발급받고 Redirect URI로 Authorization code를 클라이언트에 전달합니다. 클라이언트는 Authoriztion server에 Access Token을 요청하고 발급받습니다. 인증이 완료되면 로그인이 성공적으로 됩니다. 정리 : 사용자가 웹(사용할 서비스)에서 특정 서비스에 로그인 시도를 하여 인증요청을 합니다. 특정 서비스(구글로그인)에 로그인을 하여 웹사이트에 접근할 수 있는 권한을 부여하고 인증코드를 웹사이트에 전달합니다. 웹사이트는 인증코드를 사용하여 특정 서비스에 액세스 토큰을 받아와 이 토큰을 사용하여 사용자 정보에 접근합니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: OAuth의 장단점에 대해서 설명해주세요.

### 나라's 답변: 장점은 별도의 회원가입, 로그인 과정없이 서비스에 보다 쉬운 접근을 해줄 수 있으며 실제 로그인 정보를 공유하지 않아도 사용자의 정보에 접근가능하게 해줍니다. 단점은 해당 로그인 서비스를 제공하는 기능이 잘못되면 로그인 과정을 사용할 수 없는 점, 일반적인 로그인 과정이 아닌 Oauth를 구현하기위해 인증 절차에 대한 이해가 필요하다는 점이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: OAuth2.0과 OAuth1.0의 주요 차이점은 무엇인가요?

### 나라's 답변: 서명요구, 복잡성, 단순성이 있습니다. Oauth 1.0에서는 클라이언트와 서버간의 통신에서 서명을 요구하며, 이런 서명과정을 구현하기위해 복잡성이 올라갑니다. Oauth 2.0에서는 요청을 할 때 서명을 하지 않으며 SSL/TLS의 전송 계층 보안을 사용하여 통신보안을 거칩니다. Oauth1.0보다 간단하게 구현이 가능하며 여러 인증 유형을 지원합니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: OAuth에서 리디렉션 URL의 중요성은 무엇인가요?

### 나라's 답변:

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: JWT에 대해 설명해주세요.

### 나라's 답변: JWT(JSON Web Token)는 인증에 필요한 정보들을 암호화시킨 JSON토큰입니다. JWT기반 인증은 access Token을 HTTP헤더에 실어서 서버가 클라이언트를 식별하는 방식입니다. JSON형식으로 된 데이터를 Base 64을 통해 인코딩을 하여 직렬화했으며 개인키를 통한 전자서명이 존재합니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: JWT는 어떤 구조로 되어 있나요?

### 나라's 답변: Header, Payload, Signature로 이뤄져있으며 Header에는 JWT에 사용할 타입과 알고리즘 종류가 있으며 Payload는 서버에 첨부한 사용자의 정보와 데이터가 있습니다. Signature에는 header와 payload를 인코딩을 하고 header에 있는 해시 알고리즘을 적용한 값과 개인키로 서명한 전자서명의 값이 담겨있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: JWT의 장단점을 설명해주세요.

### 나라's 답변: JWT는 Header와 payload를 가지며 Signature로 생성되어 데이터 위변조를 막을 수 있으며 인증 정보의 저장소가 필요없습니다. 또한 토큰기반으로 인증되어 다른 로그인 시스템에 접근이 가능합니다. 하지만 토큰 자체에 정보를 담고있어 탈취당한다면 위험성이 존재하며 정보가 많아질수록 토큰의 길이가 길어져 네트워크에 부하를 줄 수 있습니다. 또한 payload에 암호화를 한것이 아닌 인코딩 과정을 거쳐 만약 탈취당해서 디코딩을 한다면 데이터가 탈취당할 위험성이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: JWT의 페이로드(Payload)에는 어떤 정보들이 담기나요?

### 나라's 답변: 실제로 사용될 정보에 대한 내용이 담기며 key-value형식으로 이뤄져있습니다. 대표적으로 Registered claims(정의된 클레임), public claims(사용자가 정의할 수 있는 클레임, 정보 전달을 위해 사용), private claims(정보를 공유하기위해 만들어진 사용자 지정 클레임, 외부에 공개되도 상관없으며 해당 유저를 특정할 수 있는 정보를 담습니다.)로 나뉘며 탈취당할 가능성이 존재하여 민감한 데이터는 넣지 않는 것이 좋습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: JWT를 사용할 때 토큰의 만료 시간을 어떻게 설정하나요?

### 나라's 답변: Payload의 exp라는 클레임(key,value쌍)으로 설정되며 이 값을 직접 계산하고 설정이 가능합니다. 탈취될 가능성을 낮출려고 유효기간을 짧게 만들 수 있지만 이것은 재로그인이 요구됩니다. 이런 문제를 해결하기위해 Refresh Token을 도입해 새로운 토큰을 발급하는 방법을 사용할 수 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: JWT는 Stateless한 특성을 가지는데, 이것의 의미와 장점은 무엇인가요?

### 나라's 답변: stateless하다는 것은 서버가 클라이언트의 상태를 저장하지 않습니다. 클라이언트가 요청에 필요한 정보들을 JWT토큰안에 포함시켜 서버는 토큰에만 따라 정보를 보내줍니다. 이러면서 서버는 사용되는 리소스가 줄어들며 성능향상을 기대할 수 있으며 추가적인 서버를 쉽게 배포가 가능하다는 장점이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 세션 기반 인증 방식과 토큰 기반 인증 방식의 차이에 대해 설명해주세요.

### 나라's 답변: 둘다 사용자를 인증하는 주요 방법이지만 가장 큰 차이점은 상태를 유지하는 것, 서버에 부하가 생기는 것, 저장하는 방식 등이 있습니다. 세션기반인증은 사용자의 정보를 서버가 저장하지만 토큰기반은 요청에 사용자의 상태를 제공하기에 서버가 사용자의 정보를 저장하지 않습니다. 이에따라 서버가 해야하는 일에 차이가 생기며 이는 서버 부하에 관려됩니다. 세션기반인증은 세션ID를 쿠키를 통해서 저장하고 관리하지만 토큰기반은 쿠키, 로컬, 세션스토리지 등에 저장될 수 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 로그인과 로그인 유지를 할 때 어떤 방식으로 구현했는지 순서대로 설명해주세요.

### 나라's 답변: 로그인을 하여 서버에서 검증을 성공적으로 마쳤다면 서버는 인증 토큰을 생성하고 클라이언트에 전송합니다. 클라이언트는 토큰을 저장하고 이후 필요 요청을 보낼 때 토큰을 HTTP헤더에 포함시켜 정보를 제공합니다. 로그인 유지는 클라이언트에서 토큰의 유효성검사와 만료됨을 주기적으로 확인합니다. 만료되지않는다면 로그인을 유지시키고 만료되었을 경우 Refresh Token을 사용하여 서버로부터 새 토큰을 생성하고 받아옵니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 소셜 로그인의 장단점은 무엇인가요?

### 나라's 답변: <!-- 답변 -->

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 비밀번호 기반 인증과 비밀번호 없는 인증의 차이점과 장단점은?

### 나라's 답변: 비밀번호 기반으로 인증한다면 사용자가 사용이 간단하며 비밀번호를 직접 설정하고 관리가 가능합니다. 또한 추가적으로 보안 옵션을 구현할 수 있지만 사용자가 비밀번호를 기억해야 로그인이 가능하며 만약 잊었다면 재설정을 해야합니다. 또한 사용자가 아닌 서비스를 제공하는 입장에서는 개인정보를 노출된다면 보안점에서 위협받을 수 있습니다. 비밀번호가 없는 인증을 한다면 사용자가 로그인정보를 기억할 필요없으며 그만큼 노출된 환경이 적다는 점이 있습니다. 하지만 비밀번호가 없기에 다른 인증 서비스에 의존해야하며, 그 속에서 또 다른 인증 단계를 거쳐야한다는 점이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 토큰 기반 인증에서 토큰이 노출되면 어떤 문제가 발생할 수 있나요?

### 나라's 답변: 서비스의 사용자가 아닌 타인이 서비스에 접근이 가능하며 토큰에 포함된 정보들이 타인에 유출되어 프라이버시 침해로 이어집니다. 이는 2차피해로 이어질 수 있는 위험이 발생합니다. 이를 방지하기 위해 HTTPS를 사용하여 통신 암호화를 이루며 토큰의 만료시간을 설정하여 하나의 토큰이 오래동안 사용되지 않게하며 리프레쉬 토큰을 사용하여 새로운 엑세스 토큰을 발급받게하는 방법이 있습니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: 2FA(Two-Factor Authentication) 또는 MFA(Multi-Factor Authentication)의 개념과 필요성은 무엇인가요?

### 나라's 답변: 2FA : 신원확인을 하는데 두가지의 다른 방법을 사용하는 인증절차, MFA : 두가지 다른 방법을 사용하여 신원을 확인하는 인증 절차, 2FA를 포함하는 넓은 범위의 개념. 이 두가지는 모두 두 가지의 다른 방법으로 인증하는 것인데, 예를 들어 비밀번호와 OTP서비스를 예로 들 수 있습니다. 이것이 필요한 이유는 하나의 인증절차보다 높은 보안을 제공하며 확실한 신원 확인이 가능기에 사용됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 🔗 꼬리질문: Single Sign-On(SSO)에 대해서 설명해주세요.

### 나라's 답변: 사용자가 단일 로그인 절차로 여러 애플리케이션이나 서비스에 접근할 수 있도록 하는 방식입니다. 즉 한번의 인증절차를 통해 모든 시스템에 접근권한을 얻습니다. 사용자가 서비스에 로그인을 하고 토큰이 발급되며 사용자는 이 토큰을 통해 서브스에 자동적으로 로그인이 되는 방식입니다. 이것은 매번 로그인을 할 필요가 없기에 사용성적인면에서 뛰어나며 사용자의 정보를 중앙관리가 가능해지며 효율성이 증가합니다. 하지만 인증 서버가 문제가 발생하면 모든 서비스가 다운되어 접근이 불가하며 보안이 해제된다면 모든 서비스에 위협이 됩니다.

### 슬기's 답변: <!-- 답변 -->

### 정호's 답변: <!-- 답변 -->

## 📝 REFERENCE

### 나라

[https://fomaios.tistory.com/entry/Network-%EC%84%B8%EC%85%98Session%EC%9D%B4%EB%9E%80-What-is-a-Session](세션)

### 슬기

<!-- 답변 -->

### 정호

<!-- 답변 -->

---
